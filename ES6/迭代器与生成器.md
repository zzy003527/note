## 迭代器与生成器

#### 迭代器(或遍历器)(Iterator)

- 概念

  - JavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。
  - 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
  - Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。

- 遍历过程

  - 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

  - 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员。

  - 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。

  - 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。

  - 每一次调用`next`方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含`value`和`done`两个属性的对象。其中，`value`属性是当前成员的值，`done`属性是一个布尔值，表示遍历是否结束。

  - 下面是一个模拟`next`方法返回值的例子

    ```js
    var it = makeIterator(['a', 'b']);
    
    it.next() // { value: "a", done: false }
    it.next() // { value: "b", done: false }
    it.next() // { value: undefined, done: true }
    
    function makeIterator(array) {
      var nextIndex = 0;
      return {
        next: function() {
          return nextIndex < array.length ?
            {value: array[nextIndex++], done: false} :
            {value: undefined, done: true};
        }
      };
    }
    
    //上面代码定义了一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组['a', 'b']执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。
    ```

- 默认Iterator接口

  - Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即`for...of`循环（详见下文）。当使用`for...of`循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。

  - 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。

  - ES6 规定，默认的 Iterator 接口部署在数据结构的`Symbol.iterator`属性，或者说，一个数据结构只要具有`Symbol.iterator`属性，就可以认为是“可遍历的”（iterable）。`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名`Symbol.iterator`，它是一个表达式，返回`Symbol`对象的`iterator`属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内

  - ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被`for...of`循环遍历。原因在于，这些数据结构原生部署了`Symbol.iterator`属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了`Symbol.iterator`属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。

  - 原生具备Iterator接口的数据结构：

    - Array
    - Map
    - Set
    - String
    - TypedArray
    - 函数的 arguments 对象
    - NodeList 对象

  - 一个对象如果要具备可被`for...of`循环调用的 Iterator 接口，就必须在`Symbol.iterator`的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。

    ```js
    class RangeIterator {
      constructor(start, stop) {
        this.value = start;
        this.stop = stop;
      }
    
      [Symbol.iterator]() { return this; }
    
      next() {
        var value = this.value;
        if (value < this.stop) {
          this.value++;
          return {done: false, value: value};
        }
        return {done: true, value: undefined};
      }
    }
    
    function range(start, stop) {
      return new RangeIterator(start, stop);
    }
    
    for (var value of range(0, 3)) {
      console.log(value); // 0, 1, 2
    }
    
    //上面代码是一个类部署 Iterator 接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。
    ```

  - 下面是另一个为对象添加 Iterator 接口的例子。

    - ```js
      let obj = {
        data: [ 'hello', 'world' ],
        [Symbol.iterator]() {
          const self = this;
          let index = 0;
          return {
            next() {
              if (index < self.data.length) {
                return {
                  value: self.data[index++],
                  done: false
                };
              }
              return { value: undefined, done: true };
            }
          };
        }
      };
      
      //
      ```

  - **对于类似数组的对象（存在数值键名和`length`属性）**，部署 Iterator 接口，有一个简便方法，就是`Symbol.iterator`方法直接引用数组的 Iterator 接口。

    ```js
    NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
    // 或者
    NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];
    
    [...document.querySelectorAll('div')] // 可以执行了
    
    
    //这是一个类似数组的对象引用数组的Iterator接口
    let iterable = {
      0: 'a',
      1: 'b',
      2: 'c',
      length: 3,
      [Symbol.iterator]: Array.prototype[Symbol.iterator]
    };
    for (let item of iterable) {
      console.log(item); // 'a', 'b', 'c'
    }
    
    
    
    //注意，普通对象部署数组的Symbol.iterator方法，并无效果。
    let iterable = {
      a: 'a',
      b: 'b',
      c: 'c',
      length: 3,
      [Symbol.iterator]: Array.prototype[Symbol.iterator]
    };
    for (let item of iterable) {
      console.log(item); // undefined, undefined, undefined
    }
    //如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。
    ```

- 调用Iterator接口的场合

  有一些场合会默认调用 Iterator 接口（即`Symbol.iterator`方法），除了下文会介绍的`for...of`循环，还有几个别的场合。

  - 解构赋值

    - 对数组和 Set 结构进行解构赋值时，会默认调用`Symbol.iterator`方法。

    - ```js
      let set = new Set().add('a').add('b').add('c');
      
      let [x,y] = set;
      // x='a'; y='b'
      
      let [first, ...rest] = set;
      // first='a'; rest=['b','c'];
      ```

  - 扩展运算符

    - 扩展运算符（...）也会调用默认的 Iterator 接口。

    - ```js
      // 例一
      var str = 'hello';
      [...str] //  ['h','e','l','l','o']
      
      // 例二
      let arr = ['b', 'c'];
      ['a', ...arr, 'd']
      // ['a', 'b', 'c', 'd']
      
      //上面代码的扩展运算符内部就调用 Iterator 接口。
      
      //实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。
      let arr = [...iterable];
      ```

  - yield

    - `yield*`后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。

    - ```js
      let generator = function* () {
        yield 1;
        yield* [2,3,4];
        yield 5;
      };
      
      var iterator = generator();
      
      iterator.next() // { value: 1, done: false }
      iterator.next() // { value: 2, done: false }
      iterator.next() // { value: 3, done: false }
      iterator.next() // { value: 4, done: false }
      iterator.next() // { value: 5, done: false }
      iterator.next() // { value: undefined, done: true }
      ```

  - 其他场合

    - 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。
      - for...of
      - Array.from()
      - Map(), Set(), WeakMap(), WeakSet()（比如`new Map([['a',1],['b',2]])`）
      - Promise.all()
      - Promise.race()

- Iterator 接口与 Generator 函数

  - `Symbol.iterator()`方法的最简单实现，还是使用 Generator 函数。

  - ```js
    let myIterable = {
      [Symbol.iterator]: function* () {
        yield 1;
        yield 2;
        yield 3;
      }
    };
    [...myIterable] // [1, 2, 3]
    
    // 或者采用下面的简洁写法
    
    let obj = {
      * [Symbol.iterator]() {
        yield 'hello';
        yield 'world';
      }
    };
    
    for (let x of obj) {
      console.log(x);
    }
    // "hello"
    // "world"
    
    //上面代码中，Symbol.iterator()方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。
    ```

- 遍历器的return()和throw()

  - 遍历器对象除了具有`next()`方法，还可以具有`return()`方法和`throw()`方法。如果你自己写遍历器对象生成函数，那么`next()`方法是必须部署的，`return()`方法和`throw()`方法是否部署是可选的。

  - `return()`方法的使用场合是，如果`for...of`循环提前退出（**通常是因为出错，或者有`break`语句**），就会调用`return()`方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署`return()`方法。

    - ```js
      function readLinesSync(file) {
        return {
          [Symbol.iterator]() {
            return {
              next() {
                return { done: false };
              },
              return() {
                file.close();
                return { done: true };
              }
            };
          },
        };
      }
      
      //上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next()方法，还部署了return()方法。下面的两种情况，都会触发执行return()方法。
      
      // 情况一
      for (let line of readLinesSync(fileName)) {
        console.log(line);
        break;
      }
      
      // 情况二
      for (let line of readLinesSync(fileName)) {
        console.log(line);
        throw new Error();
      }
      
      //上面代码中，情况一输出文件的第一行以后，就会执行return()方法，关闭这个文件；情况二会在执行return()方法关闭文件之后，再抛出错误。
      ```

    - 注意，`return()`方法必须返回一个对象，这是 Generator 语法决定的。

  

- for...of循环

  - 一个数据结构只要部署了`Symbol.iterator`属性，就被视为具有 iterator 接口，就可以用`for...of`循环遍历它的成员。也就是说，`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法。

  - `for...of`循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如`arguments`对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。

  - 数组

    - 数组原生具备`iterator`接口（即默认部署了`Symbol.iterator`属性），`for...of`循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明

    - ```js
      const arr = ['red', 'green', 'blue'];
      
      for(let v of arr) {
        console.log(v); // red green blue
      }
      
      const obj = {};
      obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);
      
      for(let v of obj) {
        console.log(v); // red green blue
      }
      
      //上面代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。
      ```

    - `for...of`循环可以代替数组实例的`forEach`方法。

      ```js
      const arr = ['red', 'green', 'blue'];
      
      arr.forEach(function (element, index) {
        console.log(element); // red green blue
        console.log(index);   // 0 1 2
      });
      ```

    - JavaScript 原有的`for...in`循环，只能获得对象的键名，不能直接获取键值。ES6 提供`for...of`循环，允许遍历获得键值

      ```js
      var arr = ['a', 'b', 'c', 'd'];
      
      for (let a in arr) {
        console.log(a); // 0 1 2 3
      }
      
      for (let a of arr) {
        console.log(a); // a b c d
      }
      ```

    - `for...of`循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟`for...in`循环也不一样

      ```js
      let arr = [3, 5, 7];
      arr.foo = 'hello';
      
      for (let i in arr) {
        console.log(i); // "0", "1", "2", "foo"
      }
      
      for (let i of arr) {
        console.log(i); //  "3", "5", "7"
      }
      
      //上面代码中，for...of循环不会返回数组arr的foo属性。
      ```

  - Set和Map结构

    - Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用`for...of`循环。

      ```js
      var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);
      for (var e of engines) {
        console.log(e);
      }
      // Gecko
      // Trident
      // Webkit
      
      var es6 = new Map();
      es6.set("edition", 6);
      es6.set("committee", "TC39");
      es6.set("standard", "ECMA-262");
      for (var [name, value] of es6) {
        console.log(name + ": " + value);
      }
      // edition: 6
      // committee: TC39
      // standard: ECMA-262
      
      //上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。
      let map = new Map().set('a', 1).set('b', 2);
      for (let pair of map) {
        console.log(pair);
      }
      // ['a', 1]
      // ['b', 2]
      
      for (let [key, value] of map) {
        console.log(key + ' : ' + value);
      }
      // a : 1
      // b : 2
      ```

  - 计算生成的数据结构

    - 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。

    - `entries()` 返回一个遍历器对象，用来遍历`[键名, 键值]`组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用`entries`方法。

    - `keys()` 返回一个遍历器对象，用来遍历所有的键名。

    - `values()` 返回一个遍历器对象，用来遍历所有的键值。

    - ```js
      let arr = ['a', 'b', 'c'];
      for (let pair of arr.entries()) {
        console.log(pair);
      }
      // [0, 'a']
      // [1, 'b']
      // [2, 'c']
      ```

  - 类似数组的对象

    - 类似数组的对象包括好几类。下面是`for...of`循环用于字符串、DOM NodeList 对象、`arguments`对象的例子

    - ```js
      // 字符串
      let str = "hello";
      
      for (let s of str) {
        console.log(s); // h e l l o
      }
      
      // DOM NodeList对象
      let paras = document.querySelectorAll("p");
      
      for (let p of paras) {
        p.classList.add("test");
      }
      
      // arguments对象
      function printArgs() {
        for (let x of arguments) {
          console.log(x);
        }
      }
      printArgs('a', 'b');
      // 'a'
      // 'b'
      ```

    - 对于字符串来说，`for...of`循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。

      ```js
      for (let x of 'a\uD83D\uDC0A') {
        console.log(x);
      }
      // 'a'
      // '\uD83D\uDC0A'
      ```

    - 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用`Array.from`方法将其转为数组。

      ```js
      let arrayLike = { length: 2, 0: 'a', 1: 'b' };
      
      // 报错
      for (let x of arrayLike) {
        console.log(x);
      }
      
      // 正确
      for (let x of Array.from(arrayLike)) {
        console.log(x);
      }
      ```

  - 对象

    - 对于普通的对象，`for...of`结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，`for...in`循环依然可以用来遍历键名。

      ```js
      let es6 = {
        edition: 6,
        committee: "TC39",
        standard: "ECMA-262"
      };
      
      for (let e in es6) {
        console.log(e);
      }
      // edition
      // committee
      // standard
      
      for (let e of es6) {
        console.log(e);
      }
      // TypeError: es6[Symbol.iterator] is not a function
      
      //上面代码表示，对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。
      ```

    - 一种解决方法是，使用`Object.keys`方法将对象的键名生成一个数组，然后遍历这个数组。

      ```js
      for (var key of Object.keys(someObject)) {
        console.log(key + ': ' + someObject[key]);
      }
      ```

    - 另一个方法是使用 Generator 函数将对象重新包装一下。

      ```js
      const obj = { a: 1, b: 2, c: 3 }
      
      function* entries(obj) {
        for (let key of Object.keys(obj)) {
          yield [key, obj[key]];
        }
      }
      
      for (let [key, value] of entries(obj)) {
        console.log(key, '->', value);
      }
      // a -> 1
      // b -> 2
      // c -> 3
      ```

    

  - 与其他遍历语法的比较

    - 以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是`for`循环。

      ```js
      for (var index = 0; index < myArray.length; index++) {
        console.log(myArray[index]);
      }
      ```

    - 这种写法比较麻烦，因此数组提供内置的`forEach`方法。

      ```js
      myArray.forEach(function (value) {
        console.log(value);
      });
      
      //这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。
      ```

    - `for...in`循环可以遍历数组的键名。

      ```js
      for (var index in myArray) {
        console.log(myArray[index]);
      }
      
      
      //for...in循环有几个缺点。
      //数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。
      //for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
      //某些情况下，for...in循环会以任意顺序遍历键名。
      //总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。
      ```

    - `for...of`循环相比上面几种做法，有一些显著的优点。

      - ```js
        for (let value of myArray) {
          console.log(value);
        }
        ```

      - 有着同`for...in`一样的简洁语法，但是没有`for...in`那些缺点。

      - 不同于`forEach`方法，它可以与`break`、`continue`和`return`配合使用。

      - 提供了遍历所有数据结构的统一操作接口。

      - 下面是一个使用 break 语句，跳出`for...of`循环的例子。

        ```js
        for (var n of fibonacci) {
          if (n > 1000)
            break;
          console.log(n);
        }
        
        //上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用break语句跳出for...of循环。
        ```

        



#### 生成器（Generator ）

- 概念

  - Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。

  - 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

  - 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，**`function`关键字与函数名之间有一个星号**；二是，**函数体内部使用`yield`表达式，定义不同的内部状态**（`yield`在英语里的意思就是“产出”）。

    ```js
    function* helloWorldGenerator() {
      yield 'hello';
      yield 'world';
      return 'ending';
    }
    
    var hw = helloWorldGenerator();
    
    //上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）
    ```

  - 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上面介绍的遍历器对象（Iterator Object）。

  - 下一步，必须调用遍历器对象的`next`方法，使得指针移向下一个状态。也就是说，每次调用`next`方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个`yield`表达式（或`return`语句）为止。换言之，Generator 函数是分段执行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。

    ```js
    hw.next()
    // { value: 'hello', done: false }
    
    hw.next()
    // { value: 'world', done: false }
    
    hw.next()
    // { value: 'ending', done: true }
    
    hw.next()
    // { value: undefined, done: true }
    
    //上面代码一共调用了4次next（）
    //第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。
    
    //第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。
    
    //第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。
    
    //第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。
    ```

  - 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的`next`方法，就会返回一个有着`value`和`done`两个属性的对象。`value`属性表示当前的内部状态的值，是`yield`表达式后面那个表达式的值；**`done`属性是一个布尔值，表示是否遍历结束。**

  - ES6 没有规定，`function`关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。

    ```js
    function * foo(x, y) { ··· }
    function *foo(x, y) { ··· }
    function* foo(x, y) { ··· }
    function*foo(x, y) { ··· }
    
    //由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。
    ```

  

- yield表达式

  - 由于 Generator 函数返回的遍历器对象，只有调用`next`方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。`yield`表达式就是暂停标志。

  - 遍历器对象的`next`方法的运行逻辑如下。

    - 遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。
    - 下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。
    - 如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。
    - 如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

  - 需要注意的是，`yield`表达式后面的表达式，只有当调用`next`方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。

    ```js
    function* gen() {
      yield  123 + 456;
    }
    
    //上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。
    ```

  - `yield`表达式与`return`语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到`yield`，函数暂停执行，下一次再从该位置继续向后执行，而`return`语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）`return`语句，但是可以执行多次（或者说多个）`yield`表达式。正常函数只能返回一个值，因为只能执行一次`return`；Generator 函数可以返回一系列的值，因为可以有任意多个`yield`。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。

  - Generator 函数可以不用`yield`表达式，这时就变成了一个单纯的暂缓执行函数。

    ```js
    function* f() {
      console.log('执行了！')
    }
    
    var generator = f();
    
    setTimeout(function () {
      generator.next()
    }, 2000);
    
    //上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。
    ```

  - **另外需要注意，`yield`表达式只能用在 Generator 函数里面，用在其他地方都会报错。**

  - `yield`表达式如果用在另一个表达式之中，必须放在圆括号里面。

    ```js
    function* demo() {
      console.log('Hello' + yield); // SyntaxError
      console.log('Hello' + yield 123); // SyntaxError
    
      console.log('Hello' + (yield)); // OK
      console.log('Hello' + (yield 123)); // OK
    }
    ```

  - `yield`表达式用作函数参数或放在赋值表达式的右边，可以不加括号。

    ```js
    function* demo() {
      foo(yield 'a', yield 'b'); // OK
      let input = yield; // OK
    }
    ```

    

- 与Iterator接口的关系

  - 上面说过，任意一个对象的`Symbol.iterator`方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。

    由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的`Symbol.iterator`属性，从而使得该对象具有 Iterator 接口。

    ```js
    var myIterable = {};
    myIterable[Symbol.iterator] = function* () {
      yield 1;
      yield 2;
      yield 3;
    };
    
    [...myIterable] // [1, 2, 3]
    
    //上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了。
    ```

  - Generator 函数执行后，返回一个遍历器对象。该对象本身也具有`Symbol.iterator`属性，执行后返回自身。

    ```js
    function* gen(){
      // some code
    }
    
    var g = gen();
    
    g[Symbol.iterator]() === g
    // true
    
    //上面代码中，gen是一个 Generator 函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。
    ```

    

- next方法的参数

  - `yield`**表达式本身没有返回值**，**或者说总是返回`undefined`。**`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。

    ```js
    function* f() {
      for(var i = 0; true; i++) {
        var reset = yield i;
        if(reset) { i = -1; }
      }
    }
    
    var g = f();
    
    g.next() // { value: 0, done: false }
    g.next() // { value: 1, done: false }
    g.next(true) // { value: -1, done: false }
    
    //上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。
    ```

  - 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过`next`方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。

  - 再看一个例子。

    ```js
    function* foo(x) {
      var y = 2 * (yield (x + 1));
      var z = yield (y / 3);
      return (x + y + z);
    }
    
    var a = foo(5);
    a.next() // Object{value:6, done:false}
    a.next() // Object{value:NaN, done:false}
    a.next() // Object{value:NaN, done:true}
    
    var b = foo(5);
    b.next() // { value:6, done:false }
    b.next(12) // { value:8, done:false }
    b.next(13) // { value:42, done:true }
    
    //上面代码中，第二次运行next方法的时候不带参数(上一个yield没有值），导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。
    
    //如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。
    
    //注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。
    ```

    

- for...of循环

  - `for...of`循环可以自动遍历 Generator 函数运行时生成的`Iterator`对象，且此时不再需要调用`next`方法。

    ```js
    function* foo() {
      yield 1;
      yield 2;
      yield 3;
      yield 4;
      yield 5;
      return 6;
    }
    
    for (let v of foo()) {
      console.log(v);
    }
    // 1 2 3 4 5
    
    //上面代码使用for...of循环，依次显示 5 个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。
    ```

  - 下面是一个利用 Generator 函数和`for...of`循环，实现斐波那契数列的例子。

    ```js
    function* fibonacci() {
      let [prev, curr] = [0, 1];
      for (;;) {
        yield curr;
        [prev, curr] = [curr, prev + curr];
      }
    }
    
    for (let n of fibonacci()) {
      if (n > 1000) break;
      console.log(n);
    }
    ```

  - 利用`for...of`循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用`for...of`循环，通过 Generator 函数为它加上这个接口，就可以用了。

    ```js
    function* objectEntries(obj) {
      let propKeys = Reflect.ownKeys(obj);
    
      for (let propKey of propKeys) {
        yield [propKey, obj[propKey]];
      }
    }
    
    let jane = { first: 'Jane', last: 'Doe' };
    
    for (let [key, value] of objectEntries(jane)) {
      console.log(`${key}: ${value}`);
    }
    // first: Jane
    // last: Doe
    
    //上面代码中，对象jane原生不具备 Iterator 接口，无法用for...of遍历。这时，我们通过 Generator 函数objectEntries为它加上遍历器接口，就可以用for...of遍历了。
    
    //加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面。
    function* objectEntries() {
      let propKeys = Object.keys(this);
    
      for (let propKey of propKeys) {
        yield [propKey, this[propKey]];
      }
    }
    
    let jane = { first: 'Jane', last: 'Doe' };
    
    jane[Symbol.iterator] = objectEntries;
    
    for (let [key, value] of jane) {
      console.log(`${key}: ${value}`);
    }
    // first: Jane
    // last: Doe
    ```

    

  - 除了`for...of`循环以外，扩展运算符（`...`）、解构赋值和`Array.from`方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。

    ```js
    function* numbers () {
      yield 1
      yield 2
      return 3
      yield 4
    }
    
    // 扩展运算符
    [...numbers()] // [1, 2]
    
    // Array.from 方法
    Array.from(numbers()) // [1, 2]
    
    // 解构赋值
    let [x, y] = numbers();
    x // 1
    y // 2
    
    // for...of 循环
    for (let n of numbers()) {
      console.log(n)
    }
    // 1
    // 2
    ```





- Generator.prototype.throw()

  - Generator 函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。

    ```js
    var g = function* () {
      try {
        yield;
      } catch (e) {
        console.log('内部捕获', e);
      }
    };
    
    var i = g();
    i.next();
    
    try {
      i.throw('a');
      i.throw('b');
    } catch (e) {
      console.log('外部捕获', e);
    }
    // 内部捕获 a
    // 外部捕获 b
    
    //上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。
    ```

  - `throw`方法可以接受一个参数，该参数会被`catch`语句接收，建议抛出`Error`对象的实例。

    ```js
    var g = function* () {
      try {
        yield;
      } catch (e) {
        console.log(e);
      }
    };
    
    var i = g();
    i.next();
    i.throw(new Error('出错了！'));
    // Error: 出错了！(…)
    
    //注意，不要混淆遍历器对象的`throw`方法和全局的`throw`命令。上面代码的错误，是用遍历器对象的`throw`方法抛出的，而不是用`throw`命令抛出的。后者只能被函数体外的`catch`语句捕获。
    ```

  - 如果 Generator 函数内部没有部署`try...catch`代码块，那么`throw`方法抛出的错误，将被外部`try...catch`代码块捕获。

    ```js
    var g = function* () {
      while (true) {
        yield;
        console.log('内部捕获', e);
      }
    };
    
    var i = g();
    i.next();
    
    try {
      i.throw('a');
      i.throw('b');
    } catch (e) {
      console.log('外部捕获', e);
    }
    // 外部捕获 a
    
    //上面代码中，Generator 函数g内部没有部署try...catch代码块，所以抛出的错误直接被外部catch代码块捕获。
    ```

  - 如果 Generator 函数内部和外部，都没有部署`try...catch`代码块，那么程序将报错，直接中断执行。

    ```js
    var gen = function* gen(){
      yield console.log('hello');
      yield console.log('world');
    }
    
    var g = gen();
    g.next();
    g.throw();
    // hello
    // Uncaught undefined
    
    //上面代码中，g.throw抛出错误以后，没有任何try...catch代码块可以捕获这个错误，导致程序报错，中断执行。
    ```

  - `throw`方法抛出的错误要被内部捕获，前提是必须至少执行过一次`next`方法。

    ```js
    function* gen() {
      try {
        yield 1;
      } catch (e) {
        console.log('内部捕获');
      }
    }
    
    var g = gen();
    g.throw(1);
    // Uncaught 1
    
    //上面代码中，g.throw(1)执行时，next方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行next方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时throw方法抛错只可能抛出在函数外部
    ```

  - `throw`方法被捕获以后，会附带执行下一条`yield`表达式。也就是说，会附带执行一次`next`方法。

    ```js
    var gen = function* gen(){
      try {
        yield console.log('a');
      } catch (e) {
        // ...
      }
      yield console.log('b');
      yield console.log('c');
    }
    
    var g = gen();
    g.next() // a
    g.throw() // b
    g.next() // c
    
    //上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。
    ```

  - 另外，`throw`命令与`g.throw`方法是无关的，两者互不影响。

    ```js
    var gen = function* gen(){
      yield console.log('hello');
      yield console.log('world');
    }
    
    var g = gen();
    g.next();
    
    try {
      throw new Error();
    } catch (e) {
      g.next();
    }
    // hello
    // world
    
    //上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。
    ```

  - 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个`yield`表达式，可以只用一个`try...catch`代码块来捕获错误。

  - Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的`catch`捕获。

    ```js
    function* foo() {
      var x = yield 3;
      var y = x.toUpperCase();
      yield y;
    }
    
    var it = foo();
    
    it.next(); // { value:3, done:false }
    
    try {
      it.next(42);
    } catch (err) {
      console.log(err);
    }
    
    //上面代码中，第二个next方法向函数体内传入一个参数 42，数值是没有toUpperCase方法的，所以会抛出一个 TypeError 错误，被函数体外的catch捕获。
    ```

  - 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用`next`方法，将返回一个`value`属性等于`undefined`、`done`属性等于`true`的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。

    ```js
    function* g() {
      yield 1;
      console.log('throwing an exception');
      throw new Error('generator broke!');
      yield 2;
      yield 3;
    }
    
    function log(generator) {
      var v;
      console.log('starting generator');
      try {
        v = generator.next();
        console.log('第一次运行next方法', v);
      } catch (err) {
        console.log('捕捉错误', v);
      }
      try {
        v = generator.next();
        console.log('第二次运行next方法', v);
      } catch (err) {
        console.log('捕捉错误', v);
      }
      try {
        v = generator.next();
        console.log('第三次运行next方法', v);
      } catch (err) {
        console.log('捕捉错误', v);
      }
      console.log('caller done');
    }
    
    log(g());
    // starting generator
    // 第一次运行next方法 { value: 1, done: false }
    // throwing an exception
    // 捕捉错误 { value: 1, done: false }
    // 第三次运行next方法 { value: undefined, done: true }
    // caller done
    
    
    //上面代码一共三次运行next方法，第二次运行的时候会抛出错误(全局throw被外部catch接收，没有被内部catch接收），然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。
    ```





- Generator.prototype.return()

  - Generator 函数返回的遍历器对象，还有一个`return()`方法，可以返回给定的值，并且终结遍历 Generator 函数。

    ```js
    function* gen() {
      yield 1;
      yield 2;
      yield 3;
    }
    
    var g = gen();
    
    g.next()        // { value: 1, done: false }
    g.return('foo') // { value: "foo", done: true }
    g.next()        // { value: undefined, done: true }
    
    //上面代码中，遍历器对象g调用return()方法后，返回值的value属性就是return()方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next()方法，done属性总是返回true。
    ```

  - 如果`return()`方法调用时，不提供参数，则返回值的`value`属性为`undefined`。

    ```js
    function* gen() {
      yield 1;
      yield 2;
      yield 3;
    }
    
    var g = gen();
    
    g.next() // { value: 1, done: false }
    g.return() // { value: undefined, done: true }
    ```

  - 如果 Generator 函数内部有`try...finally`代码块，且正在执行`try`代码块，那么`return()`方法会导致立刻进入`finally`代码块，执行完以后，整个函数才会结束。

    ```js
    function* numbers () {
      yield 1;
      try {
        yield 2;
        yield 3;
      } finally {
        yield 4;
        yield 5;
      }
      yield 6;
    }
    var g = numbers();
    g.next() // { value: 1, done: false }
    g.next() // { value: 2, done: false }
    g.return(7) // { value: 4, done: false }
    g.next() // { value: 5, done: false }
    g.next() // { value: 7, done: true }
    
    //上面代码中，调用return()方法后，就开始执行finally代码块，不执行try里面剩下的代码了，然后等到finally代码块执行完，再返回return()方法指定的返回值。
    ```

    

- next()、throw()、return() 的共同点

  - `next()`、`throw()`、`return()`这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换`yield`表达式。

  - `next()`是将`yield`表达式替换成一个值。

    ```js
    const g = function* (x, y) {
      let result = yield x + y;
      return result;
    };
    
    const gen = g(1, 2);
    gen.next(); // Object {value: 3, done: false}
    
    gen.next(1); // Object {value: 1, done: true}
    // 相当于将 let result = yield x + y
    // 替换成 let result = 1;
    
    //上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。
    ```

  - `throw()`是将`yield`表达式替换成一个`throw`语句。

    ```js
    gen.throw(new Error('出错了')); // Uncaught Error: 出错了
    // 相当于将 let result = yield x + y
    // 替换成 let result = throw(new Error('出错了'));
    ```

  - `return()`是将`yield`表达式替换成一个`return`语句。

    ```js
    gen.return(2); // Object {value: 2, done: true}
    // 相当于将 let result = yield x + y
    // 替换成 let result = return 2;
    ```

    

- yield* 表达式

  - 如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。

    ```js
    function* foo() {
      yield 'a';
      yield 'b';
    }
    
    function* bar() {
      yield 'x';
      // 手动遍历 foo()
      for (let i of foo()) {
        console.log(i);
      }
      yield 'y';
    }
    
    for (let v of bar()){
      console.log(v);
    }
    // x
    // a
    // b
    // y
    
    //上面代码中，foo和bar都是 Generator 函数，在bar里面调用foo，就需要手动遍历foo。如果有多个 Generator 函数嵌套，写起来就非常麻烦。
    ```

  - ES6 提供了`yield*`表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。

    ```js
    function* bar() {
      yield 'x';
      yield* foo();
      yield 'y';
    }
    
    // 等同于
    function* bar() {
      yield 'x';
      yield 'a';
      yield 'b';
      yield 'y';
    }
    
    // 等同于
    function* bar() {
      yield 'x';
      for (let v of foo()) {
        yield v;
      }
      yield 'y';
    }
    
    for (let v of bar()){
      console.log(v);
    }
    // "x"
    // "a"
    // "b"
    // "y"
    
    
    //再来看一个对比的例子。
    function* inner() {
      yield 'hello!';
    }
    
    function* outer1() {
      yield 'open';
      yield inner();
      yield 'close';
    }
    
    var gen = outer1()
    gen.next().value // "open"
    gen.next().value // 返回一个遍历器对象
    gen.next().value // "close"
    
    function* outer2() {
      yield 'open'
      yield* inner()
      yield 'close'
    }
    
    var gen = outer2()
    gen.next().value // "open"
    gen.next().value // "hello!"
    gen.next().value // "close"
    
    //上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。
    ```

  - 从语法角度看，如果`yield`表达式后面跟的是一个遍历器对象，需要在`yield`表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为`yield*`表达式。

    ```js
    let delegatedIterator = (function* () {
      yield 'Hello!';
      yield 'Bye!';
    }());
    
    let delegatingIterator = (function* () {
      yield 'Greetings!';
      yield* delegatedIterator;
      yield 'Ok, bye.';
    }());
    
    for(let value of delegatingIterator) {
      console.log(value);
    }
    // "Greetings!
    // "Hello!"
    // "Bye!"
    // "Ok, bye."
    
    //上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。
    ```

  - `yield*`后面的 Generator 函数（没有`return`语句时），等同于在 Generator 函数内部，部署一个`for...of`循环。

    ```js
    function* concat(iter1, iter2) {
      yield* iter1;
      yield* iter2;
    }
    
    // 等同于
    
    function* concat(iter1, iter2) {
      for (var value of iter1) {
        yield value;
      }
      for (var value of iter2) {
        yield value;
      }
    }
    
    //上面代码说明，yield*后面的 Generator 函数（没有return语句时），不过是for...of的一种简写形式，完全可以用后者替代前者。反之，在有return语句时，则需要用var value = yield* iterator的形式获取return语句的值。
    ```

  - 如果`yield*`后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。

    ```js
    function* gen(){
      yield* ["a", "b", "c"];
    }
    
    gen().next() // { value:"a", done:false }
    
    //上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。
    ```

  - 实际上，任何数据结构只要有 Iterator 接口，就可以被`yield*`遍历。

    ```js
    let read = (function* () {
      yield 'hello';
      yield* 'hello';
    })();
    
    read.next().value // "hello"
    read.next().value // "h"
    
    //上面代码中，yield表达式返回整个字符串，yield*语句返回单个字符。因为字符串具有 Iterator 接口，所以被yield*遍历。
    ```

  - 如果被代理的 Generator 函数有`return`语句，那么就可以向代理它的 Generator 函数返回数据。

    ```js
    function* foo() {
      yield 2;
      yield 3;
      return "foo";
    }
    
    function* bar() {
      yield 1;
      var v = yield* foo();
      console.log("v: " + v);
      yield 4;
    }
    
    var it = bar();
    
    it.next()
    // {value: 1, done: false}
    it.next()
    // {value: 2, done: false}
    it.next()
    // {value: 3, done: false}
    it.next();
    // "v: foo"
    // {value: 4, done: false}
    it.next()
    // {value: undefined, done: true}
    
    //上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。
    
    
    //再看一个例子。
    function* genFuncWithReturn() {
      yield 'a';
      yield 'b';
      return 'The result';
    }
    function* logReturned(genObj) {
      let result = yield* genObj;
      console.log(result);
    }
    
    [...logReturned(genFuncWithReturn())]
    // The result
    // 值为 [ 'a', 'b' ]
    
    //上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield*语句遍历函数genFuncWithReturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ 'a', 'b' ]。但是，函数genFuncWithReturn的return语句的返回值The result，会返回给函数logReturned内部的result变量，因此会有终端输出。
    ```

  - `yield*`命令可以很方便地取出嵌套数组的所有成员。

    ```js
    function* iterTree(tree) {
      if (Array.isArray(tree)) {
        for(let i=0; i < tree.length; i++) {
          yield* iterTree(tree[i]);
        }
      } else {
        yield tree;
      }
    }
    
    const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];
    
    for(let x of iterTree(tree)) {
      console.log(x);
    }
    // a
    // b
    // c
    // d
    // e
    ```

  - 由于扩展运算符`...`默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。

    ```js
    [...iterTree(tree)] // ["a", "b", "c", "d", "e"]
    ```

  - 下面是一个稍微复杂的例子，使用`yield*`语句遍历完全二叉树。

    ```js
    // 下面是二叉树的构造函数，
    // 三个参数分别是左树、当前节点和右树
    function Tree(left, label, right) {
      this.left = left;
      this.label = label;
      this.right = right;
    }
    
    // 下面是中序（inorder）遍历函数。
    // 由于返回的是一个遍历器，所以要用generator函数。
    // 函数体内采用递归算法，所以左树和右树要用yield*遍历
    function* inorder(t) {
      if (t) {
        yield* inorder(t.left);
        yield t.label;
        yield* inorder(t.right);
      }
    }
    
    // 下面生成二叉树
    function make(array) {
      // 判断是否为叶节点
      if (array.length == 1) return new Tree(null, array[0], null);
      return new Tree(make(array[0]), array[1], make(array[2]));
    }
    let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);
    
    // 遍历二叉树
    var result = [];
    for (let node of inorder(tree)) {
      result.push(node);
    }
    
    result
    // ['a', 'b', 'c', 'd', 'e', 'f', 'g']
    ```

    

- 作为对象属性的Generator函数

  - 如果一个对象的属性是 Generator 函数，可以简写成下面的形式。

    ```js
    let obj = {
      * myGeneratorMethod() {
        ···
      }
    };
    
    //上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。
    ```

  - 它的完整形式如下，与上面的写法是等价的。

    ```js
    let obj = {
      myGeneratorMethod: function* () {
        // ···
      }
    };
    ```

    

- Generator函数的this

  - Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的`prototype`对象上的方法。

    ```js
    function* g() {}
    
    g.prototype.hello = function () {
      return 'hi!';
    };
    
    let obj = g();
    
    obj instanceof g // true
    obj.hello() // 'hi!'
    
    //上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。
    
    
    
    function* g() {
      this.a = 11;
    }
    
    let obj = g();
    obj.next();
    obj.a // undefined
    
    //上面代码中，Generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。
    ```

  - Generator 函数也不能跟`new`命令一起用，会报错。

    ```js
    function* F() {
      yield this.x = 2;
      yield this.y = 3;
    }
    
    new F()
    // TypeError: F is not a constructor
    
    //上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。
    ```

  - 那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用`next`方法，又可以获得正常的`this`？

    - 下面是一个变通方法。首先，生成一个空对象，使用`call`方法绑定 Generator 函数内部的`this`。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。

      ```js
      function* F() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
      }
      var obj = {};
      var f = F.call(obj);
      
      f.next();  // Object {value: 2, done: false}
      f.next();  // Object {value: 3, done: false}
      f.next();  // Object {value: undefined, done: true}
      
      obj.a // 1
      obj.b // 2
      obj.c // 3
      
      //上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次next方法（因为F内部有两个yield表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。
      ```

    - 上面代码中，执行的是遍历器对象`f`，但是生成的对象实例是`obj`，有没有办法将这两个对象统一呢？

    - 一个办法就是将`obj`换成`F.prototype`。

      ```js
      function* F() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
      }
      var f = F.call(F.prototype);
      
      f.next();  // Object {value: 2, done: false}
      f.next();  // Object {value: 3, done: false}
      f.next();  // Object {value: undefined, done: true}
      
      f.a // 1
      f.b // 2
      f.c // 3
      ```

    - 再将`F`改成构造函数，就可以对它执行`new`命令了。

      ```js
      function* gen() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
      }
      
      function F() {
        return gen.call(gen.prototype);
      }
      
      var f = new F();
      
      f.next();  // Object {value: 2, done: false}
      f.next();  // Object {value: 3, done: false}
      f.next();  // Object {value: undefined, done: true}
      
      f.a // 1
      f.b // 2
      f.c // 3
      ```

    

- Generator与上下文

  - JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。

  - 这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。

  - Generator 函数不是这样，它执行产生的上下文环境，一旦遇到`yield`命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行`next`命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。

    ```js
    function* gen() {
      yield 1;
      return 2;
    }
    
    let g = gen();
    
    console.log(
      g.next().value,
      g.next().value,
    );
    
    //上面代码中，第一次执行g.next()时，Generator 函数gen的上下文会加入堆栈，即开始运行gen内部的代码。等遇到yield 1时，gen上下文退出堆栈，内部状态冻结。第二次执行g.next()时，gen上下文重新加入堆栈，变成当前的上下文，重新恢复执行。
    ```

  - 

  - 

  - 

  - 

  - d

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- d