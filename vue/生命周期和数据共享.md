## 生命周期和数据共享

#### 组件的生命周期

- 生命周期和生命周期函数
  - **生命周期**（Life Cycle）是指一个组件从**创建->运行->销毁**的整个阶段，**强调的是一个时间段**
  - **生命周期函数**：是由vue框架提供的**内置函数**，会伴随着组件的生命周期，**自动按次序执行**
  - 注意：**生命周期**强调的是**时间段**，**生命周期函数**强调的是**时间点**
- 组件生命周期函数的分类
  - 组件创建阶段
  - 组件运行阶段
  - 组件销毁阶段
  - ![QQ图片20220403221232](C:\Users\ZZY\Desktop\study\markdown插图\QQ图片20220403221232.png)
  - 
- 生命周期函数
  - beforeCreate
    - 组件的**props/data/methods**尚未被创建，都处于**不可用**状态
  - created
    - 组件的**props/data/methods**已创建好，都处于**可用**的状态。但是组件的**模板结构尚未生成**
    - 此函数常用于调用methods中的方法**请求服务器的数据**，并且把请求到的数据**转存到data中**，**供**template**模板渲染的时候使用**
  - beforeMount()
    - **将要把**内存中编译好的**HTML**结构**渲染到浏览器中**。此时浏览器中**还没有**当前组件的DOM结构
  - mounted()
    - 已经把内存中的HTML结构，成功的渲染到了浏览器之中。此时浏览器中**已经包含**了当前组件的**DOM结构**
    - 要操作dom元素，最早只能在mounted函数中
  - -----------------------------------------上方为组件创建阶段，下方为组件运行阶段---------------------------------------------------------------------------
  - beforeUpdate
    - **将要**根据变化过后最新的数据，**重新渲染**组件的模板结构
    - 此时数据是新的，但是UI结构还是旧的
  - updated()
    - 已经根据最新的数据，**完成了**组件DOM结构的**重新渲染**
    - 当数据变化之后，为了能够操作到最新的DOM结构，必须把代码写到updated生命周期函数中
  - -----------------------------------------上方为组件运行阶段，下方为组件销毁阶段---------------------------------------------------------------------------
  - beforeDestroy
    - **将要销毁**此组件，此时**尚未销毁**，组件还处于**正常工作**的状态
  - destroyed
    - 组件已经被销毁，此组件在浏览器中对应的**DOM结构**已被**完全移除**
    - 销毁当前组件的数据侦听器、子组件、事件监听





#### 组件之间的数据共享

- 组件之间的关系

  - 在项目开发中，组件之间的**最常见的关系**分为如下两种：
    - **父子关系**
    - **兄弟关系**

- 父子组件之间的数据共享

  - 父子组件之间的数据共享又分为：
    - **父 -> 子**共享数据
    - 子 -> 父共享数据

- 父组件向子组件共享数据

  - 父组件向子组件共享数据需要使用**自定义属性**。

  - 示例代码：

    ```js
    //父组件
    <Son :msg="message" :user="userinfo"></Son>
    
    data() {
        return {
            message: 'hello vue.js',
            userinfo: {name:'zs',age:20}
        }
    }
    
    
    
    //子组件
    <template>
        <div>
             <h5>Son组件</h5>
             <p>父组件传递过来的msg值是：{{ msg }}</p>
             <p>父组件传递过来的user值是：{{ user }}</p>
        </div>
    <?template>
                 
    props: ['msg','user']             
    ```

  - **注意：在传值之后不要修改props中属性的值**

  - 因为如果直接给props修改赋值一个对象，则子组件中的自定义属性指向另一个对象，而不是父向子传的对象；如果给props属性对象的子元素（如user.name）赋值修改，则会影响到父向子传递的那个值本身，使其一起被修改

- 子组件向父组件共享数据

  - 子组件向父组件共享数据使用**自定义事件**

  - 示例代码：

    ```js
    //父组件
    //numchange即为自定义事件
    <Son @numchange="getNewCount"></Son>       
    //上方为第一步
    
    export default {
        data() {
            return { countFromSon: 0}
        },
        methods: {       //下方为第二步
            getNewCount(val) {
                this.countFromSon = val
            }
        }
    }
        
    
    
    //子组件
    <p>count的值是{{ count }}</p>
    <button @click="add">+1</button>
    
    export default {
        data() {
            return { count: 0 }
        },
        methods: {
            add() {
                this.count += 1
                //修改数据时，通过 $emit()触发自定义事件，为第三步(this.count为numchnge事件需要的参数)
                this.$emit('numchange',this.count)
            }
        }
    }
    ```

- 兄弟组件之间的数据共享

  - 在**vue2.x**中，兄弟组件之间数据共享的方案是**EventBus**(或者嵌套较深的祖先子孙关系)

  - 示例代码：

    ```js
    //数据发送方
    import bus from './eventBus.js'
    
    export default {
        data() {
            return {
                msg:'hello vue.js'
            }
        },
        methods: {
            sendMsg() {       //触发share事件，传出this.msg
                bus.$emit('share',this.msg)
            }
        }
    }
    
    
    //eventBus.js
    import Vue from 'vue'
    //向外共享Vue的实例对象
    export default new Vue()
    
    
    
    //数据接收方
    import bus from './eventBus.js'
    
    export default {
        data() {
            return {
                msgFromLeft:''
            }
        },
        created() {     //当组件创建时，赋值传入数据
            bus.$on('share',val => {          //注册share事件，将传入的msg赋给msgFromLeft
                this.msgFromLeft = val
            })
        }
    }
    ```

  - EventBus的使用步骤

    - 创建**eventBus.js**模块，并向外共享一个**Vue的实例对象**
    - 在数据**发送方**，调用**<u>bus.$emit</u>('事件名称',要发送的数据)**方法**触发自定义事件**
    - 在数据**接收方**，调用**<u>bus.$on</u>('事件名称'，事件处理函数)**方法**注册一个自定义事件**





#### ref引用

- 什么是ref引用

  - ref用来辅助开发者在**不依赖于jQuery的情况下**，获取DOM元素或组件的引用

  - 每个vue的组件实例上，都包含一个**$refs对象**，里面储存着对应的DOM元素或组件的引用。默认情况下，**组件的$refs指向一个空对象**

  - 例子：

    ```js
    <h1 ref="myh1">App根组件</h1>
    <button @click="showThis">打印this</button>
    
     methods: {
            showThis() {
                console.log(this.$refs.myh1);
                this.$refs.myh1.style.color = 'red'
            },
        },
    ```

- 使用ref引用组件实例

  - 如果想要使用ref**引用页面上的组件实例**，则可用按照如下的方式进行操作：

    ```js
    //使用ref属性，为对应的"组件"添加引用名称
    <my-counter ref="counterRef"></my-counter>
    <button @click="getRef">获取$refs引用</button>
    
    methods: {
        getRef() {
            //通过this.$refs.引用的名称   可以引用组件的实例
            console.log(this.$refs.counterRef)
            //引用到组件的实例之后，就可以调用组件上的methods方法
            this.$refs.counterRef.add()
        }
    }
    ```

- this.**$nextTick**(cb)方法

  - 组件的**$nextTick(cb)**方法，会把cb回调**推迟到下一个DOM更新周期之后执行**。通俗的理解是：等组件的DOM更新完成之后，再执行cb回调函数。从而能保证cb回调函数可以操作到最新的DOM元素

