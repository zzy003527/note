# 编译器解析及优化(7)

- 编译器的核心由三部分组成：
  - **解析**，将类 html 模版转换为 AST 对象
  - **优化**，也叫静态标记，遍历 AST 对象，标记每个节点是否为静态节点，以及标记出静态根节点
  - **生成渲染函数**，将 AST 对象生成渲染函数



## 一、问题

### 1.1 简单说一下 Vue 的编译器都做了什么？

- Vue 的编译器做了三件事情：
  - 将组件的 html 模版解析成 AST 对象
  - 优化，遍历 AST，为每个节点做静态标记，标记其是否为静态节点，然后进一步标记出静态根节点，这样在后续更新的过程中就可以跳过这些静态节点了；标记静态根用于生成渲染函数阶段，生成静态根节点的渲染函数
  - 从 AST 生成运行时的渲染函数，即大家说的 render，其实还有一个，就是 staticRenderFns 数组，里面存放了所有的静态节点的渲染函数



### 1.2 详细说一说编译器的解析过程，它是怎么将 html 字符串模版变成 AST 对象的？

- 遍历 HTML 模版字符串，通过正则表达式匹配 "<"

  跳过某些不需要处理的标签，比如：注释标签、条件注释标签、Doctype。

  > 备注：整个解析过程的核心是处理开始标签和结束标签

  解析开始标签

  - 得到一个对象，包括 标签名（tagName）、所有的属性（attrs）、标签在 html 模版字符串中的索引位置
  - 进一步处理上一步得到的 attrs 属性，将其变成 [{ name: attrName, value: attrVal, start: xx, end: xx }, ...] 的形式
  - 通过标签名、属性对象和当前元素的父元素生成 AST 对象，其实就是一个 普通的 JS 对象，通过 key、value 的形式记录了该元素的一些信息
  - 接下来进一步处理开始标签上的一些指令，比如 v-pre、v-for、v-if、v-once，并将处理结果放到 AST 对象上
  - 处理结束将 ast 对象存放到 stack 数组
  - 处理完成后会截断 html 字符串，将已经处理掉的字符串截掉

  解析闭合标签

  - 如果匹配到结束标签，就从 stack 数组中拿出最后一个元素，它和当前匹配到的结束标签是一对。

  - 再次处理开始标签上的属性，这些属性和前面处理的不一样，比如：key、ref、scopedSlot、样式等，并将处理结果放到元素的 AST 对象上

    > **备注** 视频中说这块儿有误，回头看了下，没有问题，不需要改，确实是这样

  - 然后将当前元素和父元素产生联系，给当前元素的 ast 对象设置 parent 属性，然后将自己放到父元素的 ast 对象的 children 数组中

  最后遍历完整个 html 模版字符串以后，返回 ast 对象





### 1.3 详细说一下静态标记的过程

- 标记静态节点

  - 通过递归的方式标记所有的元素节点
  - 如果节点本身是静态节点，但是存在非静态的子节点，则将节点修改为非静态节点

  - 标记静态根节点，基于静态节点，进一步标记静态根节点
    - 如果节点本身是静态节点 && 而且有子节点 && 子节点不全是文本节点，则标记为静态根节点
    - 如果节点本身不是静态根节点，则递归的遍历所有子节点，在子节点中标记静态根节点



### 1.4 什么样的节点才可以被标记为静态节点？

- 文本节点
- 节点上没有 v-bind、v-for、v-if 等指令
- 非组件





### 1.5 详细说一下渲染函数的生成过程

- 大家一说到渲染函数，基本上说的就是 render 函数，其实编译器生成的渲染有两类：

  - 第一类就是一个 render 函数，负责生成动态节点的 vnode
  - 第二类是放在一个叫 staticRenderFns 数组中的静态渲染函数，这些函数负责生成静态节点的 vnode

  渲染函数生成的过程，其实就是在遍历 AST 节点，通过递归的方式，处理每个节点，最后生成形如：`_c(tag, attr, children, normalizationType)` 的结果。tag 是标签名，attr 是属性对象，children 是子节点组成的数组，其中每个元素的格式都是 `_c(tag, attr, children, normalizationTYpe)` 的形式，normalization 表示节点的规范化类型，是一个数字 0、1、2，不重要。

  在处理 AST 节点过程中需要大家重点关注也是面试中常见的问题有：

  - 静态节点是怎么处理的

    静态节点的处理分为两步：

    - 将生成静态节点 vnode 函数放到 staticRenderFns 数组中
    - 返回一个 _m(idx) 的可执行函数，意思是执行 staticRenderFns 数组中下标为 idx 的函数，生成静态节点的 vnode

  - v-once、v-if、v-for、组件 等都是怎么处理的

    - 单纯的 v-once 节点处理方式和静态节点一致
    - v-if 节点的处理结果是一个三元表达式
    - v-for 节点的处理结果是可执行的 _l 函数，该函数负责生成 v-for 节点的 vnode
    - 组件的处理结果和普通元素一样，得到的是形如 `_c(compName)` 的可执行代码，生成组件的 vnode





### 1.6 一个组件是如何变成 VNode？

- 组件实例初始化，最后执行 $mount 进入挂载阶段
- 如果是只包含运行时的 vue.js，只直接进入挂载阶段，因为这时候的组件已经变成了渲染函数，编译过程通过模块打包器 + vue-loader + vue-template-compiler 完成的
- 如果没有使用预编译，则必须使用全量的 vue.js
- 挂载时如果发现组件配置项上没有 render 选项，则进入编译阶段
- 将模版字符串编译成 AST 语法树，其实就是一个普通的 JS 对象
- 然后优化 AST，遍历 AST 对象，标记每一个节点是否为静态静态；然后再进一步标记出静态根节点，在组件后续更新时会跳过这些静态节点的更新，以提高性能
- 接下来从 AST 生成渲染函数，生成的渲染函数有两部分组成：
  - 负责生成动态节点 VNode 的 render 函数
  - 还有一个 staticRenderFns 数组，里面每一个元素都是一个生成静态节点 VNode 的函数，这些函数会作为 render 函数的组成部分，负责生成静态节点的 VNode
- 接下来将渲染函数放到组件的配置对象上，进入挂载阶段，即执行 mountComponent 方法
- 最终负责渲染组件和更新组件的是一个叫 updateComponent 方法，该方法每次执行前首先需要执行 vm._render 函数，该函数负责执行编译器生成的 render，得到组件的 VNode
- 将一个组件生成 VNode 的具体工作是由 render 函数中的 `_c、_o、_l、_m` 等方法完成的，这些方法都被挂载到 Vue 实例上面，负责在运行时生成组件 VNode

> **提示**：到这里首先要明白什么是 VNode，一句话描述就是 —— 组件模版的 JS 对象表现形式，它就是一个普通的 JS 对象，详细描述了组件中各节点的信息

> 下面说的有点多，其实记住一句就可以了，设置组件配置信息，然后通过 `new VNode(组件信息)` 生成组件的 VNode

- _c，负责生成组件或 HTML 元素的 VNode，_c 是所有 render helper 方法中最复杂，也是最核心的一个方法，其它的 _xx 都是它的组成部分
  - 接收标签、属性 JSON 字符串、子节点数组、节点规范化类型作为参数
  - 如果标签是平台保留标签或者一个未知的元素，则直接 `new VNode(标签信息)` 得到 VNode
  - 如果标签是一个组件，则执行 createComponent 方法生成 VNode
    - 函数式组件执行自己的 render 函数生成 VNode
    - 普通组件则实例化一个 VNode，并且在在 data.hook 对象上设置 4 个方法，在组件的 patch 阶段会被调用，从而进入子组件的实例化、挂载阶段，然后进行编译生成渲染函数，直至完成渲染
    - 当然生成 VNode 之前会进行一些配置处理比如：
      - 子组件选项合并，合并全局配置项到组件配置项上
      - 处理自定义组件的 v-model
      - 处理组件的 props，提取组件的 props 数据，以组件的 props 配置中的属性为 key，父组件中对应的数据为 value 生成一个 propsData 对象；当组件更新时生成新的 VNode，又会进行这一步，这就是 props 响应式的原理
      - 处理其它数据，比如监听器
      - 安装内置的 init、prepatch、insert、destroy 钩子到 data.hooks 对象上，组件 patch 阶段会用到这些钩子方法
- _l，运行时渲染 v-for 列表的帮助函数，循环遍历 val 值，依次为每一项执行 render 方法生成 VNode，最终返回一个 VNode 数组
- _m，负责生成静态节点的 VNode，即执行 staticRenderFns 数组中指定下标的函数

**简单总结 render helper 的作用就是**：在 Vue 实例上挂载一些运行时的工具方法，这些方法用在编译器生成的渲染函数中，用于生成组件的 VNode。







### 1.7 你能说一说 Vue 的 patch 算法吗？

- Vue 的 patch 算法有三个作用：负责首次渲染和后续更新或者销毁组件

  - 如果老的 VNode 是真实元素，则表示首次渲染，创建整棵 DOM 树，并插入 body，然后移除老的模版节点

  - 如果老的 VNode 不是真实元素，并且新的 VNode 也存在，则表示更新阶段，执行 patchVnode

    - 首先是全量更新所有的属性

    - 如果新老 VNode 都有孩子，则递归执行 updateChildren，进行 diff 过程

      > 针对前端操作 DOM 节点的特点进行如下优化：

      - 同层比较（降低时间复杂度）深度优先（递归）
      - 而且前端很少有完全打乱节点顺序的情况，所以做了四种假设，假设新老 VNode 的开头结尾存在相同节点，一旦命中假设，就避免了一次循环，降低了 diff 的时间复杂度，提高执行效率。如果不幸没有命中假设，则执行遍历，从老的 VNode 中找到新的 VNode 的开始节点
      - 找到相同节点，则执行 patchVnode，然后将老节点移动到正确的位置
      - 如果老的 VNode 先于新的 VNode 遍历结束，则剩余的新的 VNode 执行新增节点操作
      - 如果新的 VNode 先于老的 VNode 遍历结束，则剩余的老的 VNode 执行删除操纵，移除这些老节点

    - 如果新的 VNode 有孩子，老的 VNode 没孩子，则新增这些新孩子节点

    - 如果老的 VNode 有孩子，新的 VNode 没孩子，则删除这些老孩子节点

    - 剩下一种就是更新文本节点

  - 如果新的 VNode 不存在，老的 VNode 存在，则调用 destroy，销毁老节点

  