# 工程化

## Webpack的构建流程

1. 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数
2. 开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译
3. 确定入口：根据配置中的entry找出所有的入口文件
4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理
5. 完成模块编译：在经过第4步使用的Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

- 先从配置文件中读取与合并参数，然后加载所有配置的插件。从配置中的entry找出所有入口文件，然后从入口文件出发，调用所有配置的Loader对模块进行翻译，再递归处理模块的依赖。之后根据入口和模块之间的依赖关系组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表。在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统
- 
- 对我评价，公司的业务需要干啥





## git cherry-pick

- 对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。
- 这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（`git merge`）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。
- **简而言之就是你只需要某几个commit合并到别的分支就可以用**

### 基本用法

- ```bash
  $ git cherry-pick <commitHash>
  ```

  - 上面命令就会将指定的提交`commitHash`，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。
- ```bash
  $ git cherry-pick feature
  ```

  - `git cherry-pick`命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。

### 转义多个提交

- > ```bash
  > $ git cherry-pick <HashA> <HashB>
  > ```

  - 上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。

- 如果想要转移一系列的连续提交，可以使用下面的简便语法。

  ```bash
  $ git cherry-pick A..B 
  ```

  - 上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。

  - 注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。

    ```bash
    $ git cherry-pick A^..B 
    ```

  







## git rebase和git merge的区别

- git merge和git rebase都是用于分支合并，关键在于commit记录的处理上不同
  - git merge会新建一个新的commit对象，然后两个分支以前的commit记录都指向这个新的commit记录。这种方法会保留之前每个分支的commit历史
  - git rebase会找到两个分支的第一个共同的commit祖先记录，然后将提取当前分支之后的所有commit记录，然后将这个commit记录添加到目标分支的最新提交后面。
    - 经过这个合并后，两个分支合并后的commit记录就变成了线性的记录了







- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- d