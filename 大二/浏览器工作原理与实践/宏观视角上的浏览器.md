# 宏观视角上的浏览器

## 一.Chrome架构

### 1.1 什么是并行处理

- 计算机的并行处理就是同一时间处理多个任务

  - 比如：要计算下列三个式子的值，并显示出结果

    ```js
    A = 1+2
    B = 20/5
    C = 7*8
    ```

  - 在编写代码的时候，我们可以把这个过程拆分为四个任务：

    - 任务1 是计算A=1+2；
    - 任务2 是计算B=20/5；
    - 任务3 是计算C=7*8；
    - 任务4 是显示最后计算的结果

    正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。

  - 如果采用多线程

    - 只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。

- 上面这样就是并行处理





### 1.2 进程与线程

- **什么是进程**

  - **一个进程就是一个程序的运行实例。**
  - 详细解释就是**，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。**

- **什么是线程**

  - **多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的**
  - ![img](https://static001.geekbang.org/resource/image/33/da/3380f0a16c323deda5d3a300804b95da.png)
  - 线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

- **进程与线程的特点**

  1. **进程中的任意一线程执行出错，都会导致整个进程的崩溃。**

     - 如下代码：

       ```js
       A = 1+2
       B = 20/0
       C = 7*8
       ```

     - B中20/0会导致线程执行出错，进而导致进程崩溃

  2. **线程之间共享进程中的数据。**

     - 线程之间可以对进程的公共数据进行读写操作。
     - ![img](https://static001.geekbang.org/resource/image/d0/9e/d0efacd7f299ed99e776cb97da2a799e.png)
     - 如图：线程1、线程2、线程3分别把执行的结果写入A、B、C中，然后线程2继续从A、B、C中读取数据，用来显示执行结果。

  3. **当一个进程关闭之后，操作系统会回收进程所占用的内存。**

     - 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

  4. **进程之间的内容相互隔离**

     - **进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据**，也就避免出现进程A写入数据到进程B的情况。
     - 正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。
     - 如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。

     





### 1.3 单进程浏览器

- 顾名思义，**单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里**，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。
  - ![img](https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png)
  - 如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素
- **问题1：不稳定**
  - 早期浏览器需要借助于插件来实现诸如Web视频、Web游戏等各种强大的功能，但是**插件是最容易出问题的模块**，并且还运行在浏览器进程之中，所以**一个插件的意外崩溃会引起整个浏览器的崩溃**。
  - 除了插件之外，**渲染引擎模块也是不稳定的**，通常一些复杂的JavaScript代码就有可能引起渲染引擎模块的崩溃。和插件一样，**渲染引擎的崩溃也会导致整个浏览器的崩溃**

- **问题2：不流畅**
  - 从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着**同一时刻只能有一个模块可以执行**。
  - **页面的内存泄漏**也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是**使用时间越长，内存占用越高，浏览器会变得越慢**
- **问题3：不安全**
  - 插件可以使用C/C++等代码编写，**通过插件可以获取到操作系统的任意资源**，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。**如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。**
  - 至于**页面脚本，它可以通过浏览器的漏洞来获取系统权限**，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。





### 1.4 多进程浏览器

#### 1.4.1 早期多进程架构

- ![img](https://static001.geekbang.org/resource/image/cd/60/cdc9215e6c6377fc965b7fac8c3ec960.png)
- Chrome的**页面是运行在单独的渲染进程中的**，同时页面里的**插件也是运行在单独的插件进程之中**，而**进程之间是通过IPC机制进行通信（如图中虚线部分）**。
- **如何解决不稳定的问题**。
  - 由于进程是相互隔离的，所以**当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面**，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。
- **不流畅的问题是如何解决的**。
  - 同样，**JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面**，因为其他页面的脚本是运行在它们自己的渲染进程中的。
  - 对于**内存泄漏的解决方法**那就更简单了，因为**当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收**，这样就轻松解决了浏览器页面的内存泄漏问题。
- **上面的两个安全问题是怎么解决的**。
  - 采用多进程架构的额外好处是可以使用安全沙箱，**可以把沙箱看成是操作系统给进程上了一把锁**，**沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据**，例如文档和桌面。**Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限**。





#### 1.4.2 目前多进程架构

- ![img](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png)
- 最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程
- 逐个分析下这几个进程的功能。
  - **浏览器进程**。
    - 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
  - **渲染进程**。
    - 核心任务是**将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页**，**排版引擎Blink和JavaScript引擎V8都是运行在该进程中**，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，**渲染进程都是运行在沙箱模式下**。
  - **GPU进程**。
    - 其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。
  - **网络进程**。
    - 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
  - **插件进程**。
    - 主要是负责插件的运行，因插件易崩溃，所以需要**通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响**
- 缺点：
  - **更高的资源占用**。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。
  - **更复杂的体系架构**。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了





#### 1.4.3 未来多进程架构

- 为了解决这些问题，在2016年，Chrome官方团队使用“面向服务的架构”（Services Oriented Architecture，简称SOA）的思想设计了新的Chrome架构。
- Chrome最终要把UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是Chrome“面向服务的架构”的进程模型图![img](https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png)













## 二.TCP协议：如何保证页面文件能被完整送达浏览器

- 互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的



### 2.1 IP:把数据送到目的主机

- 数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称IP）标准。

- 互联网上不同的在线设备都有唯一的地址，地址只是一个数字，这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到目的地

  - **计算机的地址就称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。**

- 如果要想把一个数据包从主机A发送给主机B，

  - 那么在传输之前，**数据包上会被附加上主机B的IP地址信息**，这样在传输过程中才能正确寻址。
  - 额外地，**数据包上还会附加上主机A本身的IP地址**，有了这些信息主机B才可以回复信息给主机A。
    - 这些附加的**信息会被装进一个叫IP头的数据结构里**。**IP头是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等信息**

- 先把网络简单分为三层结构，如下图

  - ![img](https://static001.geekbang.org/resource/image/00/4d/00d9bcad0bda1fdb43ead428e89ae74d.png)

  - 上层将含有“极客时间”的数据包交给网络层；

  - 网络层再将IP头附加到数据包上，组成新的 IP数据包，并交给底层；

  - 底层通过物理网络将数据包传输给主机B；

  - 数据包被传输到主机B的网络层，在这里主机B拆开数据包的IP头信息，并将拆开来的数据部分交给上层；

  - 最终，含有“极客时间”信息的数据包就到达了主机B的上层了

    



### 2.2 UDP:把数据报送达应用程序

- IP是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？
  - 因此，需要**基于IP之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称UDP。**
- UDP中一个最重要的信息是端口号，**端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号**。
  - **通过端口号UDP就能把指定的数据包发送给指定的程序了**，所以**IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。**
  - 和IP头一样，**端口号会被装进UDP头里面**，UDP头再和原始数据包合并组成新的UDP数据包。**UDP头中除了目的端口，还有源端口号等信息**
- 将网络变为四层：
  - ![img](https://static001.geekbang.org/resource/image/3e/ea/3edb673a43f23d84253c52124ce447ea.png)
  - 上层将含有“极客时间”的数据包交给传输层；
  - 传输层会在数据包前面附加上UDP头，组成新的UDP数据包，再将新的UDP数据包交给网络层；
  - 网络层再将IP头附加到数据包上，组成新的IP数据包，并交给底层；
  - 数据包被传输到主机B的网络层，在这里主机B拆开IP头信息，并将拆开来的数据部分交给传输层；
  - 在传输层，数据包中的UDP头会被拆开，并根据UDP中所提供的端口号，把数据部分交给上层的应用程序；
  - 最终，含有“极客时间”信息的数据包就旅行到了主机B上层应用程序这里
- 在使用UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是**对于错误的数据包，UDP并不提供重发机制，只是丢弃当前的包**，而且**UDP在发送之后也无法知道是否能达到目的地。**
- 虽说**UDP不能保证数据可靠性，但是传输速度却非常快**，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等





### 2.3 TCP:把数据完整送达应用程序

- 对于浏览器请求，或者邮件这类**要求数据传输可靠性（reliability）的应用**，如果使用UDP来传输会存在两个问题：

  - **数据包在传输过程中容易丢失**；
  - 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而**UDP协议并不知道如何组装这些数据包**，从而把这些数据包还原成完整的文件

- 所以要引入TCP了。

  - TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
  - 相对于UDP，TCP有下面两个特点:
    - 对于数据包丢失的情况，**TCP提供重传机制**；
    - **TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件**。
  - 和UDP头一样，**TCP头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包**。

- TCP下单个数据包的传输流程

  - ![img](https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png)

- 一个完整的TCP连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段

  - ![img](https://static001.geekbang.org/resource/image/44/44/440ee50de56edc27c6b3c992b3a25844.png)

  - **首先，建立连接阶段**。

    - 这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。
    - TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。
    - 所谓三次握手，是指在建立一个TCP连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。

  - **其次，传输数据阶段**。

    - 在该阶段，**接收端需要对每个数据包进行确认操作**，也就是**接收端在接收到数据包之后，需要发送确认数据包给发送端。**
    - 所以**当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。**
    - 同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些**数据包到达接收端后，接收端会按照TCP头中的序号为其排序，从而保证组成完整的数据。**

  - **最后，断开连接阶段**。

    - 数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接

    







## 三.HTTP请求流程：为什么很多站点第二次打开速度会很快

- HTTP协议，正是建立在TCP连接基础之上的。
- **HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件**，例如HTML文件、CSS文件、JavaScript文件、图片、视频等。此外，HTTP也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解HTTP。
- **疑问：**
  1. 为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？
  2. 当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？



### 3.1 浏览器端发起HTTP请求流程

如果你在浏览器地址栏里键入地址：http://baidu.com， 那么接下来，浏览器会完成哪些动作呢

1. **构建请求**

   - 首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求

   - ```js
     GET /index.html HTTP1.1
     ```

2. **查找缓存**

   - **在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。**其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。
   - 当**浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求**，而不会再去源服务器重新下载。这样做的好处有：
     - **缓解服务器端压力，提升性能**（获取资源的耗时更短了）；
     - 对于网站来说，**缓存是实现快速资源加载的重要组成部分**。
   - 如果缓存查找失败，就会进入网络请求过程了。

3. **准备IP地址和端口**

   - 先看看HTTP和TCP的关系。
     - 因为**浏览器使用HTTP协议作为应用层协议，用来封装请求的文本信息**；并使用TCP/IP作传输层协议将它发到网络上，所以**在HTTP工作开始之前，浏览器需要通过TCP与服务器建立连接。**
     - ![img](https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png)
     - **HTTP网络请求的第一步**是做什么呢？
       - 结合上图看，**是和服务器建立TCP连接**。
     - 那**建立连接的信息**都有了吗？
       - **建立TCP连接的第一步就是需要准备IP地址和端口号**。
     - 那**怎么获取IP地址和端口号**呢？
       - 这得看看我们现在有什么，**我们有一个URL地址，那么是否可以利用URL地址来获取IP和端口信息呢**？
   - 我们介绍过**数据包都是通过IP地址传输给接收方的**。
     - 由于IP地址是数字标识，比如极客时间网站的IP是39.106.233.176, 难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，**负责把域名和IP地址做一一映射关系**。
     - 这套**域名映射为IP的系统就叫做“域名系统”，简称DNS**（Domain Name System）。
   - 所以，这样一路推导下来，你会发现**在第一步浏览器会请求DNS返回域名对应的IP**。当然浏览器还提供了DNS数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求
   - **拿到IP之后，接下来就需要获取端口号了**。通常情况下**，如果URL没有特别指明端口号，那么HTTP协议默认是80端口**。

4. **等待TCP队列**

   - 现在**已经把端口和IP地址都准备好了，那么下一步是不是可以建立TCP连接了**呢？
     - 答案依然是“不行”。**<u>Chrome有个机制，同一个域名同时最多只能建立6个TCP连接</u>**，**如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。**
   - 当然，**如果当前请求数量少于6，会直接进入下一步，建立TCP连接**。

5. **建立TCP连接**

   - 排队等待结束之后，终于可以快乐地和服务器握手了，在HTTP工作开始之前，浏览器通过TCP与服务器建立连接。

6. **发送HTTP请求**

   - 一旦建立了TCP连接，浏览器就可以和服务器进行通信了。而HTTP中的数据正是在这个通信过程中传输的。

   - 浏览器如何发送请求给服务器的

     - ![img](https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png)

     - **首先浏览器会向服务器发送请求行，它包括了请求方法、请求URI（Uniform Resource Identifier）和HTTP版本协议**。

       - **发送请求行，就是告诉服务器浏览器需要什么资源**，**最常用的请求方法是Get**。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要Get它的首页资源。
       - **另外一个常用的请求方法是POST，它用于发送一些数据给服务器**，比如登录一个网站，就需要通过POST方法把用户信息发送给服务器。**如果使用POST方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送**。

     - **在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器**。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的Cookie信息

       









### 3.2 服务器端处理HTTP请求流程

1. **返回请求**

   - 一旦服务器处理结束，便可以返回数据给浏览器了。返回的结果如下图所示：
     - ![img](https://static001.geekbang.org/resource/image/3e/76/3e30476a4bbda49fd7cd4fd0ea09f076.png)
   - **首先服务器会返回响应行，包括协议版本和状态码。**
     - 但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：
       - 最常用的状态码是200，表示处理成功；
       - 如果没有找到页面，则会返回404-
   - 随后，**正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头**。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的Cookie等信息。
   - **发送完响应头后，服务器就可以继续发送响应体的数据**，通常，响应体就包含了HTML的实际内容。

2. **断开连接**

   - 通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。
   - 不过如果浏览器或者服务器在其头信息中加入了：`Connection:Keep-Alive`
     - **那么TCP连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个TCP连接发送请求。**
     - **保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。**比如，一个Web页面中内嵌的图片就都来自同一个Web站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的TCP连接。

3. ‘**重定向**

   - 到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开geekbang.org后，你会发现最终打开的页面地址是 https://www.geekbang.org。

     - 这两个URL之所以不一样，是因为**涉及到了一个重定向操作**。

   - 如果有了重定向，那么返回的结果是：

     - ![img](https://static001.geekbang.org/resource/image/01/6b/01db98e08233dba5847fab171ce95e6b.png)

     - 从图中你可以看到，**响应行返回的状态码是301，状态301就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的Location字段中**

     - 接下来，**浏览器获取Location字段中的地址，并使用该地址重新导航**，这就是一个完整重定向的执行流程

     - 这也就解释了为什么输入的是 geekbang.org，最终打开的却是 https://www.geekbang.org 了。

       





### 3.3 问题解答

#### 3.3.1 为什么很多站点第二次打开速度会很快？

- 如果第二次页面打开很快，**主要原因是第一次加载页面过程中，缓存了一些耗时的数据**。

- 那么，**哪些数据会被缓存**呢？

  - 从上面介绍的核心请求路径可以发现，**DNS缓存和页面资源缓存这两块数据是会被浏览器缓存的**。

  - 其中，DNS缓存比较简单，它主要就是在浏览器本地把对应的IP和域名关联起来

  - 重点看下浏览器资源缓存，下面是缓存处理的过程：

    - ![img](https://static001.geekbang.org/resource/image/16/02/1670e353bf6cccc096e63e0f102ed502.png)

    - 从上图的第一次请求可以看出，当服务器返回HTTP响应头给浏览器时，**浏览器是通过响应头中的`Cache-Control`字段来设置是否缓存该资源**。通常，我们还需要**为这个资源设置一个缓存过期时长，而这个时长是通过`Cache-Control`中的`Max-age`参数来设置的**，比如上图设置的缓存过期时间是2000秒:

      ```js
      Cache-Control:Max-age=2000
      ```

      - **这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器**。

    - 但**如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP请求头中带上**：

      ```js
      If-None-Match:"4f80f-13c-3a1xb12a"
      ```

      - **服务器收到请求头后，会根据`If-None-Match`的值来判断请求的资源是否有更新**。
        - 如果**没有更新，就返回304状态码**，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”
        - 如果**资源有更新，服务器就直接返回最新资源给浏览器**。

- 简要来说，**很多网站第二次访问能够秒开，是因为这些<u>网站把很多资源都缓存在了本地</u>，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，<u>DNS数据也被浏览器缓存了，这又省去了DNS查询环节</u>**





#### 3.3.2 登录状态是如何保持的？

- 用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后**调用POST方法提交用户登录信息给服务器。**

- **服务器接收到浏览器提交的信息之后**，查询后台，验证用户登录信息是否正确，**如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的`Set-Cookie`字段里，如下所示，然后把响应头发送给浏览器**

  - ```js
    Set-Cookie: UID=3431uad;
    ```

- **浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有Set-Cookie字段的情况，浏览器就会把这个字段信息保存到本地**。比如把UID=3431uad保持到本地。

- 当用户再次访问时，浏览器会发起HTTP请求，但在**发起请求之前，浏览器会读取之前保存的Cookie数据，并把数据写进请求头里的Cookie字段里（如下所示），然后浏览器再将请求头发送给服务器。**

  - ```js
    Cookie: UID=3431uad;
    ```

- **服务器在收到HTTP请求头数据之后，就会查找请求头里面的“Cookie”字段信息**，当查找到包含UID=3431uad的信息时，服务器查询后台，**并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。**

- 浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了

- 流程图：

  - ![img](https://static001.geekbang.org/resource/image/d9/b3/d9d6cefe8d3d6d84a37a626687c6ecb3.png)

- 简单地说，**如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。**





#### 3.3.3 小结

- ![img](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png)
- 浏览器中的HTTP请求从发起到结束一共经历了如下**八个阶段：构建请求、查找缓存、准备IP和端口、等待TCP队列、建立TCP连接、发起HTTP请求、服务器处理请求、服务器返回请求和断开连接。**











## 四. 导航流程：从输入URL到页面展示这中间发生了什么

### 4.1 概括

- 完整流程图：

  - ![img](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)

- 回顾下浏览器进程、渲染进程和网络进程的主要职责。

  - **浏览器进程**主要负责用户交互、子进程管理和文件储存等功能。
  - **网络进程**是面向渲染进程和浏览器进程等提供网络下载功能。
  - **渲染进程**的主要职责是把从网络下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么Chrome会让渲染进程运行在安全沙箱里，就是为了保证系统的安全

- **整个流程包含了许多步骤。这个过程可以大致描述为如下**：

  - 首先，用户从浏览器进程里输入请求信息；
  - 然后，网络进程发起URL请求；
  - 服务器响应URL请求之后，浏览器进程就又要开始准备渲染进程了；
  - 渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为**提交文档阶段**；
  - 渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。

  这其中，**用户发出URL请求到页面开始解析的这个过程，就叫做导航。**







### 4.2 详细流程

#### 4.2.1 **用户输入**

- **当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的URL**。
  - 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
    - 如果判断输入内容符合URL规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如 https://time.geekbang.org。
- **当用户输入关键字并键入回车之后**，浏览器便进入下图的状态：
  - ![img](https://static001.geekbang.org/resource/image/fa/30/fad33fc7c5f2bdf4e20cac7691484130.png)
  - 从图中可以看出，**当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态**。
  - 但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为**需要等待提交文档阶段，页面内容才会被替换。**







#### 4.2.2 **URL请求过程**

- 接下来，便进入了页面资源请求过程。这时，**浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程**，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

- 首先，**网络进程会查找本地缓存是否缓存了该资源**。

  - 如果有缓存资源，那么直接返回资源给浏览器进程；
  - 如果在缓存中没有查找到资源，那么直接进入网络请求流程。这**请求前的第一步是要进行DNS解析**，以获取请求域名的服务器IP地址。**如果请求协议是HTTPS，那么还需要建立TLS连接**。

- 接下来就是**利用IP地址和服务器建立TCP连接**。

  - 连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后**向服务器发送构建的请求信息**。

- **服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给<u>网络进程</u>**。

  - 等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。

- **（1）重定向**

  - 在接收到服务器返回的响应头后，网络进程开始解析响应头，**如果发现返回的状态码是301或者302**，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头的Location字段里面读取重定向的地址，然后再发起新的HTTP或者HTTPS请求，一切又重头开始了。
  - 在终端里输入以下命令：`curl -I http://time.geekbang.org/`
    - `curl -I + URL`的命令是接收服务器返回的响应头的信息。执行命令后，我们看到服务器返回的响应头信息如下：![img](https://static001.geekbang.org/resource/image/65/7e/655cbf32dd4bb6f9decc5c7f9a535a7e.png)
    - 从图中可以看出，极客时间服务器会通过重定向的方式把所有HTTP请求转换为HTTPS请求。也就是说你使用HTTP向极客时间服务器请求时，服务器会返回一个包含有301或者302状态码响应头，并把响应头的Location字段中填上HTTPS的地址，这就是告诉了浏览器要重新导航到新的地址上。
  - 再使用HTTPS协议对极客时间发起请求，看看服务器的响应头信息是什么样子的
    - `curl -I https://time.geekbang.org/`,返回：![img](https://static001.geekbang.org/resource/image/0c/43/0c4987fe5d05646fa8245d8cc50d1a43.png)
    - 从图中可以看出，服务器返回的响应头的状态码是200，这是告诉浏览器一切正常，可以继续往下处理该请求了。
  - **在导航过程中，如果服务器响应行的状态码包含了301、302一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是200，那么表示浏览器可以继续处理该请求。**

  

- **（2）响应数据类型处理**

  - 在处理了跳转信息之后，我们继续导航流程的分析。**URL请求的数据类型，有时候是一个下载类型，有时候是正常的HTML页面，那么浏览器是如何区分它们呢**？

    - 答案是`Content-Type`。**`Content-Type`是HTTP头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。**

  - 在终端输入以下命令：`curl -I https://time.geekbang.org/`

    - 返回信息为：![img](https://static001.geekbang.org/resource/image/89/1c/8951e161b5f44a73e52c16b631a63e1c.png)
    - 图中可以看到，响应头中的Content-type字段的值是text/html，这就是告诉浏览器，服务器返回的数据是HTML格式。

  - 再来利用curl来请求极客时间安装包的地址，如下所示：`curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk`

    - 返回结果为：![img](https://static001.geekbang.org/resource/image/59/3b/595902748d7d4c2f9c1d4783962ae43b.png)
    - 从返回的响应头信息来看，其Content-Type的值是application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。

  - **注意**

    - 如果服务器配置Content-Type不正确，比如将text/html类型配置成application/octet-stream类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。

    - **不同Content-Type的后续处理流程也截然不同。**

      - 如果Content-Type字段的值被浏览器判断为**下载类型**，那么该请求会被**提交给浏览器的下载管理器**，**同时该URL请求的导航流程就此结束。**
      - 但如果是**HTML**，那么**浏览器则会继续进行导航流程**。由于Chrome的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

      





#### 4.2.3 准备渲染进程

- 默认情况下，**Chrome会为每个页面分配一个渲染进程**。也就是说，**每打开一个新页面就会配套创建一个新的渲染进程**。

- 但是，也有一些例外，**在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中**。

  - 比如从极客时间的首页里面打开了另外一个页面——算法训练营，我们看下图的Chrome的任务管理器截图：

    - ![img](https://static001.geekbang.org/resource/image/d8/28/d8fe2afbd8ea2d4a8d8cc4bb14c50f28.png)
    - 从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程ID是23601

  - 那**什么情况下多个页面会同时运行在一个渲染进程中**呢？

    - 要解决这个问题，我们就需要先了解下**什么是同一站点（same-site）**。

      - 具体地讲，我们将**“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口**，比如下面这三个：

        ```js
        https://time.geekbang.org
        https://www.geekbang.org
        https://www.geekbang.org:8080
        ```

      - 它们都是属于同一站点，因为它们的协议都是HTTPS，而且根域名也都是geekbang.org。

    - **Chrome的默认策略是，每个标签对应一个渲染进程**。

      - 但**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。**官方把这个默认策略叫`process-per-site-instance`。

    - 那**若新页面和当前页面不属于同一站点**，情况又会发生什么样的变化呢？

      - 比如我通过极客邦页面里的链接打开InfoQ的官网（https://www.infoq.cn/ ）， 因为infoq.cn和geekbang.org不属于同一站点，所以infoq.cn会**使用一个新的渲染进程**

  - 总结来说，**打开一个新页面采用的渲染进程策略**就是：

    - **通常情况下，打开新的页面都会使用单独的渲染进程；**
    - **如果从A页面打开B页面，且A和B都属于同一站点的话，那么B页面复用A页面的渲染进程；如果是其他情况，浏览器进程则会为B创建一个新的渲染进程。**

- 渲染进程准备好之后，还不能立即进入文档解析状态，因为**此时的文档数据还在网络进程中**，并没有提交给渲染进程，所以**下一步就进入了提交文档阶段**







#### 4.2.4 提交文档

- 首先要明确一点，这里的**“文档”是指URL请求的响应体数据**。
  - **“提交文档”的消息是由<u>浏览器进程发出</u>的**，**<u>渲染进程</u>接收到“提交文档”的消息后，会<u>和网络进程建立</u>传输数据的“管道”**。
  - 等**文档数据传输完成之后，<u>渲染进程</u>会返回“确认提交”的消息<u>给浏览器进程</u>。**
  - **<u>浏览器进程在收到</u>“确认提交”的消息后，会更新浏览器界面状态**，包括了**安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。**
    - 更新内容：![img](https://static001.geekbang.org/resource/image/a1/6f/a1b77a61361561e74e86fdae10ee246f.png)
- 这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。
- **到这里，一个完整的导航流程就“走”完了**，这之后就要进入渲染阶段了。







#### 4.2.5 渲染阶段 

- 一旦文档被提交，渲染进程便开始页面解析和子资源加载了
- **一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画**。
  - 如下所示：![img](https://static001.geekbang.org/resource/image/be/58/bef45eb5b01c34e328486004feedd658.png)
- 至此，一个完整的页面就生成了







### 4.3 总结

- **从输入URL到页面展示，这中间发生了什么**
  - 用户输入url并回车
  - 浏览器进程检查url，组装协议，构成完整的url
  - 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
  - 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
  - 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
    - 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
    - 利用ip地址和服务器建立tcp连接
    - 构建请求头信息
    - 发送请求头信息
    - 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
  - 网络进程解析响应流程
    - 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
    - 200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
  - 准备渲染进程
    - 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
  - 传输数据、更新状态
    - 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
    - 渲染进程接收完数据后，向浏览器发送“确认提交”
    - 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面
- 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。
- Chrome默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。
- **浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。**
- **导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁**













## 五.渲染流程：HTML、CSS和JavaScript是如何变成页面的

- 由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线
  - 其大致流程如下图所示：![img](https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png)
  - 按照渲染的时间顺序，流水线可分为如下几个子阶段：**构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**。内容比较多，我会用两篇文章来为你详细讲解这各个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容
    - **开始每个子阶段都有其输入的内容；**
    - **然后每个子阶段有其处理过程；**
    - **最终每个子阶段会生成输出内容。**





### 5.1 构建DOM树

- **为什么要构建DOM树呢**？

  - 这是因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构——DOM树。

- **什么是树结构**

  - ![img](https://static001.geekbang.org/resource/image/fc/38/fcad0a4e3e73c796f00d6120284a3638.png)
  - 从图中可以看出，树这种结构非常像我们现实生活中的“树”，其中每个点我们称为节点，相连的节点称为父子节点。

- **DOM树的构建过程**

  - ![img](https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png)

  - **构建DOM树的输入内容是一个非常简单的HTML文件，然后经由HTML解析器解析，最终输出树状结构的DOM。**

    





### 5.2 样式计算

- **样式计算的目的是为了计算出DOM节点中每个元素的具体样式**，这个阶段大体可分为三步来完成



#### 5.2.1 把CSS转换为浏览器能够理解的结构

- 那**CSS样式的来源主要有哪些**呢？
  - ![img](https://static001.geekbang.org/resource/image/bc/7c/bc93df7b8d03b2675f21e1d9e4e1407c.png)
  - 从图中可以看出，CSS样式来源主要有三种：
    - 通过link引用的外部CSS文件
    - `<style>`标记内的 CSS
    - 元素的style属性内嵌的CSS
    - 和HTML文件一样，**浏览器也是无法直接理解这些纯文本的CSS样式，所以当渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构——styleSheets**。
    - 为了加深理解，你可以在Chrome控制台中查看其结构，只需要在控制台中输入`document.styleSheets`，然后就看到如下图所示的结构![img](https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png)
- **渲染引擎会把获取到的CSS文本全部转换为styleSheets结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础**





#### 5.2.2 转换样式表中的属性值，使其标准化

- 现在我们**已经把现有的CSS文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。**

- **什么是属性值标准化**

  - 看一段css文本：

    ```css
    body { font-size: 2em }
    p {color:blue;}
    span  {display: none}
    div {font-weight: bold}
    div  p {color:green;}
    div {color:red; }
    ```

  - 可以看到上面的CSS文本中有很多属性值，如2em、blue、bold，这些**类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化**。

  - **标准化后的属性值是什么样子的？**

    - ![img](https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png)

    - 从图中可以看到，2em被解析成了32px，red被解析成了rgb(255,0,0)，bold被解析成了700……

      





#### 5.2.3 计算出DOM树中每个节点的具体样式

- 现在样式的属性已被标准化了，接下来就需要计算DOM树中每个节点的样式属性了，如何计算呢？

- **这就涉及到CSS的继承规则和层叠规则了。**

  - 首先是CSS继承。**CSS继承就是每个DOM节点都包含有父节点的样式**。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到DOM节点上的

    - ```css
      body { font-size: 20px }
      p {color:blue;}
      span  {display: none}
      div {font-weight: bold;color:red}
      div  p {color:green;}
      ```

    - 这张样式表最终到DOM树上的效果：

      - ![img](https://static001.geekbang.org/resource/image/fe/b4/fe9a0ea868dc02a3c4a59f6080aa80b4.png)
      - 从图中可以看出，**所有子节点都继承了父节点样式**。比如body节点的font-size属性是20，那body节点下面的所有节点的font-size都等于20。

    - 要加深对CSS继承的理解，可以打开Chrome的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，会看到如下界面：

      - ![img](https://static001.geekbang.org/resource/image/88/b2/88a3aac427cc7c09361eac01a85fc7b2.png)

      - 这个界面展示的信息很丰富，大致可描述为如下

        - 首先，可以选择要查看的元素的样式（位于图中的区域2中），在图中的第1个区域中点击对应的元素元素，就可以了下面的区域查看该元素的样式了。比如这里我们选择的元素是`<p>`标签，位于`html.body.div.`这个路径下面
        - 其次，可以从样式来源（位于图中的区域3中）中查看样式的具体来源信息，看看是来源于样式文件，还是来源于UserAgent样式表。这里需要特别提下UserAgent样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是UserAgent样式。
        - 最后，可以通过区域2和区域3来查看样式继承的具体过程。

        

  - 样式计算过程中的第二个规则是样式层叠。**层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法**。它在CSS处于核心地位，CSS的全称“层叠样式表”正是强调了这一点。

    - 特性：
      - 给同一个标签设置不同的样式--->此时样式会层层叠加--->会共同作用在标签上
      - 给同一个标签设置相同的样式--->此时样式会层叠覆盖--->最终写在最后的样式会生效
    - 注意点：**当样式冲突时，<u>只有当选择器优先级相同时</u>，才能通过层叠性判断结果**

- 总之，**样式计算阶段的目的是为了计算出DOM节点中每个元素的具体样式，在计算过程中需要遵守CSS的继承和层叠两个规则。这个阶段最终输出的内容是每个DOM节点的样式，并被<u>保存在ComputedStyle</u>的结构内。**

- 如你想了解每个DOM元素最终的计算样式，可以打开Chrome的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：

  - ![img](https://static001.geekbang.org/resource/image/d8/46/d87415b0187e3860404bf963f1c3d646.png)
  - 上图红色方框中显示了html.body.div.p标签的ComputedStyle的值。想要查看哪个元素，点击左边对应的标签就可以了













### 5.3 布局阶段

- 现在，我们有DOM树和DOM树中元素的样式，但这还不足以显示页面，因为我们还不知道DOM元素的几何位置信息。那么接下来就需要**计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局**。
- Chrome在布局阶段需要完成两个任务：**创建布局树和布局计算**



#### 5.3.1 创建布局树

- DOM树还含有**很多不可见的元素，比如head标签，还有使用了`display:none`属性的元素**。所以**在显示之前，我们还要额外地构建一棵<u>只包含可见元素布局树</u>**。

- 结合下图来看看布局树的构造过程：

  - ![img](https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png)

  - 从上图可以看出，**DOM树中所有不可见的节点都没有包含到布局树中**。

  - 为了构建布局树，浏览器大体上完成了下面这些工作：

    - 遍历DOM树中的所有可见节点，并把这些节点加到布局中；
    - 而不可见的节点会被布局树忽略掉，如`head`标签下面的全部内容，再比如`body.p.span`这个元素，因为它的属性包含 `dispaly:none`，所以这个元素也没有被包进布局树

    



#### 5.3.2 布局计算

- 现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。后续(5.4~5.7)将是详细介绍
- **在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容**，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome团队正在重构布局代码，下一代布局系统叫LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单
- ![img](https://static001.geekbang.org/resource/image/a4/9a/a4a0ea4da58260aafc9aabdd37613f9a.png)









### 5.4 分层

- **因为页面中有很多复杂的效果**，如一些复杂的3D变换、页面滚动，或者使用z-indexing做z轴排序等，**为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的<u>图层树（LayerTree）</u>**。

- 要想直观地理解什么是图层，你可以打开Chrome的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况

  - 如下图所示![img](https://static001.geekbang.org/resource/image/e2/c0/e2c917edf5119cddfbec9481372f8fc0.png)

  - 从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，可以参考下图![img](https://static001.geekbang.org/resource/image/cd/78/cd6aac705501d48bda6e8eebca058b78.png)

    

- 现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看**这些图层和布局树节点之间的关系**

  - 如图所示：![img](https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png)

  - 通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层**。如上图中的span标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，**最终每一个节点都会直接或者间接地从属于一个层。**

    

- **需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢**？通常**满足下面两点中任意一点**的元素就可以被提升为单独的一个图层。

  - **第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**

    - 页面是个二维平面，但是层叠上下文能够让HTML元素具有三维概念，这些HTML元素按照自身属性的优先级分布在垂直于这个二维平面的z轴上。你可以结合下图来直观感受下：![img](https://static001.geekbang.org/resource/image/a0/19/a03eb12053aac1ac496b61a424f20119.png)
    - 从图中可以看出，**明确定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等，都拥有层叠上下文属性**。

  - **第二点，需要剪裁（clip）的地方也会被创建为图层。**

    - **什么是剪裁**

      - 结合下面的HTML代码：

        ```html
        <style>
              div {
                    width: 200;
                    height: 200;
                    overflow:auto;
                    background: gray;
                } 
        </style>
        <body>
            <div >
                <p>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>
                <p>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>
                <p>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p> 
            </div>
        </body>
        ```

      - 在这里我们把div的大小限定为200 * 200像素，而div里面的文字内容比较多，文字所显示的区域肯定会超出200 * 200的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在div区域，下图是运行时的执行结果![img](https://static001.geekbang.org/resource/image/6a/0c/6a583733735edc1e4d7946740eb6fc0c.png)

      - 出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，**如果出现滚动条，滚动条也会被提升为单独的层**。你可以参考下图：![img](https://static001.geekbang.org/resource/image/7b/97/7b6ceaab23c6c6d8e5930864ff9d7097.png)

        

  - **所以说，元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。**







### 5.5 图层绘制

- **在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制**，那么接下来我们看看**渲染引擎是怎么实现图层绘制**的？
- **渲染引擎实现图层的绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表**
  - 如下图所示：![img](https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png)
  - 从图中可以看出，**绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作**，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。
  - 所以**在图层绘制阶段，输出的内容就是这些待绘制列表**。
- 你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表
  - 如下图所示：![img](https://static001.geekbang.org/resource/image/30/70/303515c26fcd4eaa9b9966ad7f190370.png)
  - 在该图中，区域1就是document的绘制列表，拖动区域2中的进度条可以重现列表的绘制过程







### 5.6 栅格化（raster）操作

- **绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的**。
- 可以结合下图来看下渲染主线程和合成线程之间的关系：
  - ![img](https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png)
  - 如上图所示，**当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程**，那么接下来合成线程是怎么工作的呢
  - **什么是视口**
    - 参考下图：![img](https://static001.geekbang.org/resource/image/24/72/242225112f2a3ec97e736c960b88d972.png)
    - 通常一个页面可能很大，但是用户只能看到其中的一部分，我们把**用户可以看到的这个部分叫做视口（viewport）。**
    - 在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。
  - 基于这个原因，**合成线程会将图层划分为图块（tile），这些图块的大小通常是256x256或者512x512**
    - 如下图所示：![img](https://static001.geekbang.org/resource/image/bc/52/bcc7f6983d5ece8e2dd716f431d0e052.png)
  - 然后**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的**。
    - 所谓**栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。**
    - **渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的**，运行方式如下图所示：![img](https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png)
    - 通常，**栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中**。
    - 而**GPU操作是运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作**。具体形式你可以参考下图：![img](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png)
      - 从图中可以看出，**渲染进程把生成图块的指令发送给GPU，然后在GPU中执行生成图块的位图，并保存在GPU的内存中**









### 5.7 合成和显示

- **一旦所有图块都被光栅化，<u>合成线程</u>就会生成一个绘制图块的命令——“DrawQuad”，然后<u>将该命令提交给浏览器进程</u>**。
- 浏览器进程里面有一个叫`viz`的组件，用来接收合成线程发过来的`DrawQuad`命令，然后**根据`DrawQuad`命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。**
- 到这里，经过这一系列的阶段，编写好的HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面了。





### 5.8 流水线大总结

- 从HTML到DOM、样式计算、布局、图层、绘制、光栅化、合成和显示，用一张图来总结下这整个渲染流程：![img](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)
- **结合上图，一个完整的渲染流程大致可总结为如下**
  - 渲染进程将HTML内容转换为能够读懂的DOM树结构。
  - 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
  - 创建布局树，并计算元素的布局信息。
  - 对布局树进行分层，并生成分层树。
  - 为每个图层生成绘制列表，并将其提交到合成线程。
  - 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
  - 合成线程发送绘制图块命令DrawQuad给浏览器进程。
  - 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上







### 5.9 相关概念

#### 5.9.1 更新了元素的几何属性（重排、回流）

- ![img](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)
- 从上图可以看出，如果**通过JavaScript或者CSS修改元素的几何位置属性**，例如改变元素的宽度、高度等，**那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。**
- 无疑，**重排需要更新完整的渲染流水线，所以开销也是最大的**
- 会导致重排（回流）的操作
  - 页面首次渲染（无法避免且开销最大的一次）
  - 浏览器窗口大小发生改变（resize事件）
  - 元素尺寸或位置发生改变（边距、宽高、边框等）
  - 元素内容变化（文字数量或图片大小等等）
  - 元素字体大小变化（font-size）
  - 添加或者删除**可见**的`DOM`元素
  - 激活`CSS`伪类（例如：`:hover`）
  - 查询某些属性或调用某些方法







#### 5.9.2 更新元素的绘制属性（重绘）

- 接下来，我们再来看看**重绘**，比如**通过JavaScript更改某些元素的背景颜色**，渲染流水线会怎样调整呢？可以参考下图：

  ![img](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

- 从图中可以看出，如果**修改了元素的背景颜色，那么布局阶段将不会被执行**，**因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘**。

- **相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**。

- 如何减少重排（回流reflow）与重绘（repaint）

  - 对css样式的改变尽量通过改变类名来修改
  - 如果需要对DOM进行多次访问，尽量使用局部变量缓存该DOM
  - 避免使用table布局，可能很⼩的⼀个⼩改动会造成整个table的重新布局
  - DOM离线处理，减少重绘回流次数
    - 比如将DOM节点display：none，然后进行修改，修改完毕再将其block，这样只会触发这一次重绘与回流
    - 或者通过 documentFragment创建一个 `dom` 文档片段,在它上面批量操作 `dom`，操作完成之后，再添加到文档中
  - DOM脱离普通文档流，如（absolute或fixed），可以减少对其他节点的影响
  - 触发repaint、reflow的操作尽量放在一起，比如改变DOM高度和设置margin分开写，可能会出发两次重排
  - 通过虚拟dom层计算出操作总得差异，一起提交给浏览器。之前还用过createdocumentfragment来汇总append的dom,来减少触发重排重绘次数。

  





#### 5.9.3 直接合成阶段

- 那如果**更改一个既不要布局也不要绘制的属性**，会发生什么变化呢？**渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。**具体流程参考下图

  ![img](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png)

- 在上图中，我们**使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作**。

- **这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。**

  