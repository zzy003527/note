

### indexMap

![1663154381454](images/1663154381454.png)

10kV梅斜线大概名字叫这样的线

![1663154423858](images/1663154423858.png)

是从indexMap这个组件来的 那么这个数据就是馈线的数据

indexMap就是用来渲染馈线数据的组件

这个indexMap就在src/views/indexMap.vue里面

#### 搜索馈线

```
@input="searchCircuitLine($store.state.allCircuitLine, $event)"
```

@input每输入一个字符都会触发该事件，用于实时查询

```js
  <v-text-field dark hide-details class="ml-16" prepend-icon="mdi-magnify" single-line width="100px" clearable
          label="搜索馈线" @input="searchCircuitLine($store.state.allCircuitLine, $event)"></v-text-field>

```

```js

data(){
    //就是搜索馈线的最终搜索结果
    searchRet:[];
}
methods:{
    //搜索馈线的函数
    searchCircuitLine(lines, info) {
      //$store.state.allCircuitLine就是传入的lins 是所有的馈线信息 info就是input里面输入的信息
      this.searchRet = [];
      if (info === null) return;
      let line = lines.filter((item) => {
        const reg = new RegExp(info.trim(), "ig");
        return (
          info &&
          (reg.test(item.circuitLineName) || reg.test(item.circuitLineMRid) ||            reg.test(item.transSubstationName))
        );
      });
      //返回的line是过滤后的新数组
      line && this.searchRet.push(...line.slice(0, 5));
    },
}
```

lins是所有的馈线信息



#### yyMap

在indexmap里面

```js
import yyMap from "../components/yy-cpns/yy-map";
```

写在组件一栏

```js
  components: {
    yyMap,
    yyPlanning,
    BaseBar,
  },
```



写在方法里面的renderLine中

```js
  // 如果设备是线
          if (
            this.$yyMap.judgeType(this.$yyMap.setKeyTypeToDeviceType(key)) ===
            "line"
          ) {
            lines.push(
              ...this.$yyMap.backDataToMapData(
                element,
                this.$yyMap.setKeyTypeToDeviceType(key),
                styleId || index
              )
            );
          } else {
            if (key === "transSubstationVO") {
              if (index === 0) {
                center = this.$yyMap.locatToLatLng(element.location);
              }

              let lineInfo = {};

              if (isAll) {
                lineInfo = {
                  circuitLineName: element.circuitLineName,
                  transSubstationName: element.name,
                  center: element.location,
                  mRid: element.circuitLineMRid,
                };
                linesLocaInfo.push(lineInfo);
              }

              // 否则 如果设备是点
              transSubs.push(
                ...this.$yyMap.backDataToMapData(
                  element,
                  this.$yyMap.setKeyTypeToDeviceType(key),
                  "transSub" + element.name.split("kV")[0]
                )
              );
            } else {
              // 否则 如果设备是点
              markers.push(
                ...this.$yyMap.backDataToMapData(
                  element,
                  this.$yyMap.setKeyTypeToDeviceType(key)
                )
              );
            }
          }
```



在上面代码里面的

```
judgeType
```

是来自yyMap.js中

```js
/**
 * 判断数据类型在地图中为 'marker' 还是 'line'
 * @param {String} type 数据模型名称
 * 
 * return：String('marker'/'line')
 */
const judgeType = function (type) {
  if (typeof type !== 'string') {
    throw new Error(`错误参数类型${type}`)
  }
  switch (type) {
    case _OPT_._PROPS_.POWERTRANSFORMER:
    case _OPT_._PROPS_.POLE:
    case _OPT_._PROPS_.POLESITE:
    case _OPT_._PROPS_.SUBSTATION:
    case _OPT_._PROPS_.JUNCTION:
    case _OPT_._PROPS_.BREAKER:
    case _OPT_._PROPS_.DISCONNECTOR:
    case _OPT_._PROPS_.FUSE:
    case _OPT_._PROPS_.GROUNDDISCONNECTOR:
    case _OPT_._PROPS_.LOADBREAKSWITCH:
    case _OPT_._PROPS_.RINGSWITCH:
    case _OPT_._PROPS_.TRANSSUBSTATION:
      return 'marker'
    case _OPT_._PROPS_.ACLINESEGMENT:
      return 'line'
    default:
    // throw new Error(`错误数据类型:${type}`)
  }
}
```

如何配置地球信息？在bigmap演示文档实例中

```js
// 在ID为map的元素中实例化一个地图，不要设置地图ID，ID号程序自动生成，无需手动配置，设置中心点，默认的级别和显示级别控件
    var map = BM.map('map', null, {center: [ 30,104], zoom: 3, zoomControl: true,attributionControl:false});
```

```js
//引入配置数据
import * as _OPT_ from "@/data/mapOptions.js";
```

在mapOption.js

```js
//地图初始配置
export const _MAPOPT_ = function (options) {
    return {
        zoom: 14, //缩放级别
        center: options.center, //中心点
        maxZoom: 18,
    }
}
```







那么yy-map.js是怎么和yy-map.vue联系起来的？

```js
import * as _OPT_ from "@/data/mapOptions.js";
```

yy-single-tablevue面有

```js
      $yyMap.judgeType(
                $store.state.curData.currentDevice.properties.deviceType
              ) === 'marker'
```

仿佛yyMap是data里面的数据 查看这个文件的import 就是yy-single-table.vue

```js
import * as API from "../../network/api";
import * as _TABLE_ from "@/utils/tableConstant";
import { getState } from "@/utils";
```

再看indexMap.vue的import

```js
import yyMap from "../components/yy-cpns/yy-map";
import yyPlanning from "../components/yy-cpns/yy-planning";
import * as API from "../network/api";
import * as _OPT_ from "@/data/mapOptions.js";
import BaseBar from "../components/bz-cpns/BaseBar/BaseBar";
import {
  getState
} from '../utils';
```

可以发现他们两个文件重合的是

```js
import * as API from "../network/api";
import { getState } from "@/utils";
```

但是这两个声明都别有用处，打印了indexMap中的this.$yyMap

![1663225503635](images/1663225503635.png)

这个上面绑定的方法都是再yyMap.js里面的

再打印了this

![1663226541351](images/1663226541351.png)



如果注释掉在indexMap.vue上面的话，地图就会无法渲染出来，但是this.$yyMap还是可以正常使用

```js
import yyMap from "../components/yy-cpns/yy-map";
  components: {
    yyMap,
  },
```

找到main.js

```js
//引入yy封装
import $yyHot from './utils/yyHot'
import $yyMap from './utils/yyMap'
Vue.prototype.$yyHot = $yyHot
Vue.prototype.$yyMap = $yyMap
```

所以说this.$yyMap是来自yyMap.js和本身的yy-Map组件是没有关系的

### yyMap.vue

```html
 <yy-map style="
          height: 85vh;
          position: absolute;
          width: 100%;
          left: 0;
          top: 0;
          right: 0;
          bottom: 0;
        " allLineMapId="map" ref="map" :canSearch="false"></yy-map>
```

indexMap里面

```js
 props: {
    canSearch: {
      type: Boolean,
      default: true,
    },
    allLineMapId: String,
  },
```



```html
  <!-- 地图 -->
    <div ref="map" class="yy-map" :id="`map${mapId}`"></div>
```

有一个地图的盒子

css地址和js地址放在

index.html

```html
    <link href='http://222.200.98.221:8888/bigemap.js/v2.1.0/bigemap.css' rel='stylesheet'/>
    <script defer src='http://222.200.98.221:8888/bigemap.js/v2.1.0/bigemap.js'></script>
```

#### 初始化地图

```js
   /**
     * 1.初始化地图
     */
    initMap() {
      BM.Config.HTTP_URL = "http://222.200.98.221:8888";

      // 老师服务器？ 理解：这里有两个图层，图层1和图层2
      //这里的bigemap.64w6r9wg？？包括两个图层的意义？
      let lay1 = BM.tileLayer("bigemap.64w6r9wg");
      let lay2 = BM.tileLayer("bigemap.81zjnqcq");

      // 地图配置信息
      const config = {
   //BM.CRS.EPSG4326	小叶1.0使用符合EPSG的TMS坐标方案：4326，如果你的TileLayer 用于此CRS，请确保在缩放级别位0时覆盖整个地球上有两个256x256的常被CIS极客盖瓦片，并且瓦片坐标为（-180，+ 90）和（-180，-90）在TileLayer的tms配置  ？不懂，不重要
        crs: BM.CRS.EPSG4326,
        //
        center: _OPT_._PROPS_.CENTER,
        zoom: _OPT_._PROPS_.ORIGIN_ZOOM,
        minZoom: _OPT_._PROPS_.MIN_ZOOM,
        maxZoom: _OPT_._PROPS_.MAX_ZOOM,
        trackResize: false,
        layers: [lay1, lay2],
        zoomControl: false,
        doubleClickZoom: false,
        preferCanvas: true,
      };

      //预设信息加入地图 实例化一个地图元素
      //null是false
      let mapObj = BM.map(`map${this.mapId}`, null, config);
      console.log(this.allLineMapId); //这里打印出来就是map
        //判断是否在规划窗口，如果在规划窗口就更新planmap这个数据，如果不是就更新在allLinemap的数据
        //这里是indexmap里面传入的是map
      if (this.allLineMapId) {
        this.$yyHot.update("allLineMap", mapObj);
      } else {
        this.$yyHot.update("planMap", mapObj);
      }

      // 加入控件(缩放)
      mapObj.addControl(BM.control.zoom({ position: "bottomleft" }));

      // 标尺控件
      mapObj.addControl(
        BM.control.scale({ position: "bottomright", imperial: false })
      );
      //是否在规划窗口 
      if (getState("isDrawing")) {
         //给mapobj添加一个图层
        const drawLayer = new BM.FeatureGroup();
        drawLayer.addTo(mapObj);
        this.$yyHot.update("layers.drawLayer", drawLayer);
      }

      this.$yyHot.update("mapData.mapObj", mapObj);
    }
```



###### 图层

```js
//现在地图上面有一个地图实例map
var map = BM.map('map', null, {center: [ 30,104], zoom: 3, zoomControl: true,attributionControl:false});
//创建一个图层arcgis_satellite
var arcgis_satellite=BM.tileLayer('bigemap.arcgis-satellite');
//把这个图层添加到这个地图元素上面去
arcgis_satellite.addTo(map);
//在map元素上移除这个图层
arcgis_satellite.remove(map);
```

```js
BM.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
```

网址模板

以下形式的字符串：

```
'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
```

`{s}`装置可用的子域中的一个（顺序地用于帮助每个域限制浏览器并行请求;子域值在选项中指定; `a`，`b`或`c`通过默认，可省略），`{z}`-缩放级别，`{x}`以及`{y}`-瓷砖坐标。`{r}`可用于将“@ 2x”添加到URL以加载视网膜图块。您可以在模板中使用自定义键，这些键将从TileLayer选项中进行[评估](http://www.bigemap.com/offlinemaps/api/#util-template)，如下所示：

```
BM.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
```

#### 什么时候执行初始化

```js
  created() {
    let _this = this;
    window.test = _this.test;

    this.mapId = window.mapId ? ++window.mapId : (window.mapId = 1);
    window.bigemapId = 1;

    // DOM加载完毕后执行
    this.$nextTick(() => {
      //执行初始化
      this.init();
    });
  },
```

在 Vue 生命周期的 created() 钩子函数进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中

注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted

在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick() 的回调函数中。与之对应的就是 mounted() 钩子函数，因为该钩子函数执行时所有的 DOM 挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。

init()

```js
    
//这个init只是执行配置初始化，还没有渲染到页面上面
init() {
      //创建地图
      this.initMap();

      //初始化Markers相关
      this.initMarkers();

      // 初始化Lines相关
      this.initLines();

      //监听事件初始化 拖动框相关
      this.initListener();
    },
```

#### 初始化线

地图已经渲染出来了，上面的线还有杆塔是怎么渲染的？

```js
    /**
     * 4.初始化线
     */
    initLines() {
      //配置生成
      let lineOption = {};
      for (const key in _OPT_._LINESSTYLE_) {
        if (_OPT_._LINESSTYLE_.hasOwnProperty(key)) {
          lineOption[key] = _OPT_._LINESSTYLE_[key];
        }
      }
        //在vuex中更新数据
      this.$yyHot.update("mapData.lineOption", lineOption);
    },

    showLineInfo() {
      this.$yyHot.update("curLine.info", this.lineInfo);
    },
```

就算没有yy-plannnging这个地图上面也有线 yy-planning是规划线的

initLi在什么时候执行的？

### 渲染馈线

- 这个渲染馈线会根据不同的现在的页面状况进行不同的馈线渲染

  在规划窗口的话调用就会把线段渲染到地图上面，并且给给整个图层添加监听事件

  如果没有在规划窗口，就将线段渲染到地图上面，不添加监听事件



```js
 //在indexMap上面怎么调用的？  this.$refs.map.initLi(lines, { isNew });
//isNew是renderLine里面传过来的
/**
     * 渲染馈线
     */
    async initLi(lines, opt = {}) {
      let lr = [];
      //判断当前是否在规划窗口
      if (getState("isDrawing")) {
          //对这个馈线数组进行forEach遍历
        lines.forEach(li => {
           //li.paths里面是这个线段的点信息
          if(li.paths) {
            let dash = li.properties.type === '配电-电缆' ? { dashArray: '5,5' } : {};
            //添加线段到地图上面
            let line = BM.polyline(li.paths, {...getState('mapData').lineOption[li.styleId](dash), id: ++window.bigemapId});
            li.map_id = window.bigemapId;
            lr.push(line)
          }
        })
          //添加一个featureGroup图层，便于对所有成员图层进行操作
        let layer = BM.featureGroup(Object.freeze(lr))
                        .addTo(getState('mapData').mapObj)
       //给这个图层添加监听事件
        layer.addEventListener('click', e => {
          this.myFun(e, [...getState('lines'), ...getState('newLines')])
        })
          //更新vuex中的数据
        this.$yyHot.update(["mapData.linesArr", "layers.linesLayer"], [lr, layer]);
      } 
        //如果当前不在规划窗口
        else {
        lines.forEach(li => {
            //添加线段到地图上面
          if(li.paths) {
            let dash = li.properties.type === '配电-电缆' ? { dashArray: '5,5' } : {};
            BM.polyline(li.paths, {...getState('mapData').lineOption[li.styleId](dash), id: ++window.bigemapId}).addTo(getState('mapData').mapObj)
            li.map_id = window.bigemapId
          }
        })
      }
      //如果不是的话就更新线路图层，是的话就更新潮流图层 判断现在是不是潮流
      if (opt.isFlow) {
        this.$yyMap.clearLayers('flowLayer')
        this.$yyHot.update("layers.flowLayer", BM.featureGroup(lr).addTo(getState('mapData').mapObj));
        getState('layers').flowLayer.addEventListener('click', e => {
          this.myFun(e, lines)
        })
      } else {
        this.$yyHot.update("mapData.linesArr", lr);
      }
    }
```

如何给地图添加线段

```js
        //创建线段，并设置颜色为红色，具体请参见 :http://www.bigemap.com/offlinemaps/api/#polyline
        var polyline = BM.polyline(latlngs, {color: 'red'}).addTo(map);
  // 让地图适配当前的线段
        map.fitBounds(polyline.getBounds());
```

添加线段方法传入的参数

```js
BM.polyline( <LatLng[]> latlngs, <Polyline options> options?)
```

- latings：坐标
- options：可选参数，用一个对象包起来

```js
     let line = BM.polyline(li.paths, {...getState('mapData').lineOption[li.styleId](dash), id: ++window.bigemapId});
```

打印了lines的信息

![1663471546320](images/1663471546320.png)

lines里面paths是里面的点信息

#### FeatureGroup

FeatureGroup会处理来自子图层的鼠标事件和自定义事件，



#### layers

```js
 layers: {
    // 杆塔图层
    markerLayer: null,
    // 线路图层
    linesLayer: null,
    // 变电站图层
    transSubLayers: null,
    // 规划图层
    drawLayer: null,
    // 潮流layer
    flowLayer: null,

    // 首页杆塔图层:
    allMarkersLayer: null,
    // 潮流图层
    newLayer: null
  },
```

这个潮流layer是什么？

如果不是的话就更新线路图层，是的话就更新潮流图层







#### getState

```js
import { getState } from "../../utils";
```

```js
//在index.js里面
export function getState(name) {
  return store.state[name]
}
```

```js
//在state里面
// 当前是否在规划窗口
  isDrawing: false,
```







### 怎么处理的接口信息

##### lines里面信息是怎么样的

![1663471528042](images/1663471528042.png)

```js
//在indedxMap里面
async loadAllLine() {
      this.loadingDeviceData = true;

      // 获取数据
      this.getIndexData();
      //调用获取馈线信息和图元的信息的接口
      await API.getAllLine({
        pageNum: 1,
        pageSize: 4,
      })
        .then((res) => {
          //成功调用后调用renderLine来处理数据
          this.renderLine(res.data, null, true);
          console.log(res.data);
          setTimeout(() => {
             //调用成功1秒后关闭加载设备中的这个显示
            this.loadingDeviceData = false;
          }, 1000);
        })
        .catch((err) => {
          this.$yyHot.showSnackbar({
            text: err.message || "请求超时，请刷新重试",
            type: "error",
          });
        });
    },
```

上面是发送请求获取馈线信息的接口，里面也包括图元信息

![1663664978909](images/1663664978909.png)

这个数组的结构：每个元素是一条馈线的信息，里面包含了馈线上面的变电站、开关元件的位置





调用成功之后就是这样子

![1663665157051](images/1663665157051.png)

```
ACLineSegmentVOLiast 是电缆 交流线段
breakerVOList 是断路器列表
circuitLineMRid 馈线id
circuitLineName 馈线名字
junctionVOList 电缆中间接头
loadBreakSwitchVOList 柱上负荷开关
pole 架空线，杆塔
powerTransformerVOList:变压器
ringSwitchVOList
substationVOList 变电站
transSubstationVO 

```

renderLine来处理这些馈线的信息 

```js
//在indexMap里面
// this.renderLine(res.data, null, true); 
//进入reenderLine后res就是上面的截图 这次调用isAll=true
renderLine(res, styleId, isAll = false, isNew = false) {
      // 所有馈线信息 allCircuitLine: null,在vuex里面的store更新
      isAll && this.$yyHot.update('allCircuitLine', res);
      let lines = [];
      let markers = [];
      let transSubs = []; //绿色、玫红色的圆圈（变电站）
      let center = null;
      const linesLocaInfo = [];

      res.forEach((data, index) => {
         //以上面的res[0]做示例
        // 遍历单个线路的所有设备
        for (let key in data) {
          if (
            //circuitLineMRid应该是梅斜线的id，circuitLineName就是馈线的名字
            key === "circuitLineMRid" ||
            key === "circuitLineName" ||
            key === "ringSwitchVOList" ||
            key === "powerTransformerVOList"
          ) {
            continue;
          }
            //假设key是transSubstationVO
          const element = data[key];
          // 将 馈线名称放进对象中 
            //这里等于判断这个element是不是数组？
          if (element instanceof Array) {
              //数组的map方法 1、map() 方法返回一个新数组，新数组中的元素为原始数组中的每个元素调用函数处理后得到的值。2、map() 方法按照原始数组元素顺序依次处理元素。注意： map() 不会对空数组进行检测。注意： map() 不会改变原始数组。
              //让每个元件都有它对应的馈线的名字
            element.map(
              (item) => (item.circuitLineName = data.circuitLineName)
            );
          } //假设key是transSubstationVO，因为element是对象，所以就走这里 
            else if (element instanceof Object) {
            element.circuitLineName = data.circuitLineName;
          }
          // 如果设备是线
          if (
              // case _OPT_._PROPS_.ACLINESEGMENT:  return 'line'
              //所以只要key是acLineSegmentVOList，就是这里面 
            this.$yyMap.judgeType(this.$yyMap.setKeyTypeToDeviceType(key)) ===
            "line"
          ) {
            //lines就是很多个线段的对象
            lines.push(
              ...this.$yyMap.backDataToMapData(
                element,
                this.$yyMap.setKeyTypeToDeviceType(key),
                styleId || index
              )
            );
          } //
            else {
            if (key === "transSubstationVO") {
              if (index === 0) {
                center = this.$yyMap.locatToLatLng(element.location);
              }

              let lineInfo = {};

              if (isAll) {
                lineInfo = {
                  circuitLineName: element.circuitLineName,
                  transSubstationName: element.name,
                  center: element.location,
                  mRid: element.circuitLineMRid,
                };
                linesLocaInfo.push(lineInfo);
              }

         
              transSubs.push(
                ...this.$yyMap.backDataToMapData(
                  element,
                  this.$yyMap.setKeyTypeToDeviceType(key),
                  "transSub" + element.name.split("kV")[0]
                )
              );
            } else {
              // 否则 如果设备是点
              markers.push(
                ...this.$yyMap.backDataToMapData(
                  element,
                  this.$yyMap.setKeyTypeToDeviceType(key)
                )
              );
            }
          }
        }
      });

      isAll && this.$yyHot.update('linesLocaInfo', Object.freeze(linesLocaInfo));
      this.$refs.map.initLi(lines, { isNew });
      this.$refs.map.initMa(markers, null, { isAll, isNew });
      this.$refs.map.initMa(transSubs, null, { isTransSub: true, isNew });
    }
```

这个接口

```js
/**
 * 获取所有馈线
 *
 */
export function getAllLine(config) {
  return chRequest({
    url: LLT + NWOPT.GETALLCIRCUITLINEDATA,
    params: config,
  })
}
```

```js
export const LLT = 'http://222.200.112.93:8888/sg/electric1'
   // 获取所有馈线
    GETALLCIRCUITLINEDATA: '/circuitLine/getAllCircuitLine',
```



如果设备是线，就要调用yyMap.js里面的backDataToMapdata

```js
* 地图单个标注点数据模型：
 * PointGeometry：
 *   id：String——唯一 id，没有会随机生成
 *   styleId：String——样式 id
 *   position：LatLng(Object)——标注点坐标 格式为 Latlng 对象
 *   rank：Number——标注点的图层内绘制顺序（暂时不用）
 *   properties：Object——存放自定义数据（存放后台设备模型数据）
 * 
 * return：Array 返回处理完的数组
 */
//调用的形式
//   ...this.$yyMap.backDataToMapData(
//                element,
//                this.$yyMap.setKeyTypeToDeviceType(key),
//              styleId || index
//              )
const backDataToMapData = function (dataArr, type, style = null) {
   //如果不是数组形式的，就把它包装成为一个数组形式的
  if (!Array.isArray(dataArr)) {
    dataArr = [dataArr]
  }
  //这里和上面一样，调用judgeType函数来判断这个数组里面数据的类型
  switch (judgeType(type)) {
    case 'marker':
      let tempData = [];
      dataArr.forEach((item) => {
        try {
          //单个标记点数据
          let tempItem = {};
          //标记点唯一标识：id
          tempItem.id = item.id;
          //标记点样式id：styleId
          if (style === null) {
            tempItem.styleId = type || _OPT_._MARKERSSTYLE_.DEFAULT;
          } else {
            tempItem.styleId = getMarkerStyle(style) || style
          }
          //标记点位置
          tempItem.position = locatToLatLng(item.location)
          //自定义属性(存留后台原始数据所有属性)
          tempItem.properties = {
            ...item,
            //添加种类以示区别
            deviceType: type,
          };
          tempData.push(tempItem);
        } catch (error) {
          console.error(error);
        }

      });
      return tempData;
    case 'line':
       //如果是线的话，里面一个一个的数组实则是这个馈线的线段
      let tempLineArr = [];
      dataArr.forEach((item) => {
        //单个线数据
        let tempItem = {};
        tempItem.id = item.id; //线唯一标识 这个是这个线段自己的id，不同于馈线的id

        let paths = [];

        // 按location格式数据加入
        if (item.location) {
            //根据示例，这里面的item.location是一个数组，里面每个元素又是一个两个元素的数组，这里面的两个元素就是这个线段上面的点信息 paths就是一个线段里面点的对象的集合
          paths.push(...locatToLatLng(item.location));
        }
        
        tempItem.paths = paths; //标记点位置

        if (style === null) {
          // 获取线路样式id
          let level = parseInt(item.fzl);
          tempItem.styleId = getLoadRateStyle(level);
        } else {
          if (getLineStyle(style)) {
            tempItem.styleId = getLineStyle(style)
          } else if (/^style_.+/.test(style)) {
            tempItem.styleId = style
          } else {
            switch (item.type) {
              case 'jkx':
              case '配电-架空线段':
                tempItem.styleId = 'style_red_dash';
                break;
              case 'dl':
              case '配电-电缆':
                tempItem.styleId = 'style_blue_dash'
                break;
            }
          }
          // tempItem.styleId = getLineStyle(style) || (item.type === 'jkx' ? 'style_red_dash' : 'style_blue_dash')
        }
        //每个线段里面需要的数据都包在这个tempItem的对象里面，未处理的原始数据就放在原型链里面
        tempItem.properties = {
          //自定义属性（保存后台全部数据）
          ...item,
          //添加种类区别
          deviceType: type,
        };
          //最后把每个下是你的福安对象都推进这个tempLineArr数组里面
        tempLineArr.push(tempItem);
      });
      // console.log('tempLineArr' + JSON.stringify(tempLineArr));
      return tempLineArr;
  }
}

```

上面以例子![1663760410408](images/1663760410408.png)

element为acLineSEgmentVOList里面的282长度的数据为例子、

![1663760617352](images/1663760617352.png)

里面的每个元素就以第一个元素作为示例

![1663761147436](images/1663761147436.png)



上面的locatToLating方法是从yyMap.js里面调用，用来把

```js
const locatToLatLng = function (location) {
  if (location === undefined) {
    throw new Error('坐标不存在')
  }
  if (location instanceof Array) {
    if (location.length === 1) {
      //一段线（返回对象）
      return BM.latLng(location[0][0], location[0][1])
    } else {
      //多段折线（返回数组）
      let latLng = [];
      for (const i in location) {
        //创建地理点对象放进latLing
        latLng.push(BM.latLng(location[i][0], location[i][1]));
      }
      return latLng
    }
  }
}
```

```js
BM.latLng( <Number> latitude, <Number> longitude, <Number> altitude?)	创建表示具有给定纬度和经度（以及可选的高度）的地理点的对象。
```













### 下面这个initLi在yy-planning中的调用

```js
this.$refs.yyMap.initLi([...getState("lines"), ...getState('newLines')]);
```

ref 加在子组件上，用this.$refs.（ref值） 获取到的是**组件实例，可以使用组件的所有方法**。在使用方法的时候直接this.$refs.（ref值）.方法（） 就可以使用了。

还有在indexMap中的调用

```js
this.$refs.map.initLi(lines, { isNew });
```

```js
 <yy-map style="
          height: 85vh;
          position: absolute;
          width: 100%;
          left: 0;
          top: 0;
          right: 0;
          bottom: 0;
        " allLineMapId="map" ref="map" :canSearch="false"></yy-map>
```

这里是把yy-map作为实例对象

![1663402362138](images/1663402362138.png)



#### 搜索框

yy-map有一个隐藏起来的搜索框

```js
  <!-- 搜索浮动工具栏 -->
    <v-toolbar dense floating absolute class="rounded float-tools-class" style="z-index: 1" v-if="canSearch">
      <v-text-field hide-details prepend-icon="mdi-magnify" single-line width="100px" clearable
        @input="searchDevice($event)"></v-text-field>
    </v-toolbar>
```

是用来搜索设备的

```js
    // 搜索设备
    searchDevice(key) {
      // 先清空
      this.searchRet = [];

      if (key === null) return;
      // 搜索
      let res = this.$yyMap.searchDeviceByName(key.trim());
      // 写入
        //这里这样是如果res为null就不用执行后面的代码
        //只取前面六个展开
      res && this.searchRet.push(...res.slice(0, 6));
    },

```

在yyMap.js里面有

```js
// 根据名称搜索馈线
const searchDeviceByName = function (name) {
  if (!name) {
    return
  }
  return [...store.state.markers, ...store.state.lines].filter(item => {
      
    const reg = new RegExp(name, 'ig')
    return (reg.test(item.properties.name) || reg.test(item.properties.id))
  })
}

```

markers和lines数据是什么

```js
  // 转为地图展示的markers数据
  markers: [],
  // 转为地图展示的lines数据
  lines: [],
```

正则

```js
   var expression = new RegExp("pattern ", "flags") ;
```

    g ：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
    i ：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
    m ：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
搜索之后还可以定位

```js
     <v-btn text color="primary accent-4" @click="locateToLine(item)">
                定位
              </v-btn>
```

定位这个馈线的函数

```js
    // 定位馈线
    locateToLine(item) {
      this.$yyMap.setMapCenter(
        getState('mapData').mapObj,
        false,
        {
          latLng: this.$yyMap.locatToLatLng(item.properties.location),
          message: item.properties ? item.properties.name : item.circuitLineName
        }
      );
      this.searchRet = []
    }
```

调用setMapCenter传入的参数

```js
  // 地图对象
  mapData: {
    //地图实例化
     mapObj: null
     }
```

参数content里面的latLing

```js
const locatToLatLng = function (location) {
  if (location === undefined) {
    throw new Error('坐标不存在')
  }
  if (location instanceof Array) {
    if (location.length === 1) {
      //一段线（返回对象）
      return BM.latLng(location[0][0], location[0][1])
    } else {
      //多段折线（返回数组）
      let latLng = [];
      for (const i in location) {
        latLng.push(BM.latLng(location[i][0], location[i][1]));
      }
      return latLng
    }
  }
}
```



里面主要是调用了setMapCenter这个函数，然后将搜索列表清空

```js
const setMapCenter = function (mapObj, latLng, content) {
  let ll = null
  if (typeof latLng === 'object' && latLng[0]) {
    // 如果是定位馈线
    // mapObj = store.state.allLineMap
    ll = locatToLatLng([latLng])
  } else if (content.latLng[0] && typeof content.latLng[0] === 'object' && content.latLng[1] && typeof content.latLng[1] === 'object') {
    // 如果是线
    ll = {
      lat: (content.latLng[0][0] + content.latLng[1][0]) / 2,
      lng: (content.latLng[0][1] + content.latLng[1][1]) / 2
    }
  } else {
    // 如果是点
    ll = content.latLng
  }

  if (ll) {
    mapObj.panTo(ll)

    store.state.popup = BM.popup({
      className: 'a'
    })
      .setLatLng(ll || {})
      .setContent(content.message)
      .openOn(mapObj)
  }
}
```



### 图元图标选择

```js
//撑杆选择 
poleOptions: [
        {
          url: require("../../assets/icons/杆塔+架空线.png"),
          ref: "jkx-pole",
          title: "架空线-杆塔",
        },
        {
          url: require("../../assets/icons/杆塔+电缆.png"),
          ref: "dl-pole",
          title: "电缆-杆塔",
        },
        {
          url: require("../../assets/icons/电缆终端头+架空线.png"),
          ref: "jkx-junction",
          title: "架空线-电缆终端头",
        },
        {
          url: require("../../assets/icons/电缆终端头+电缆.png"),
          ref: "dl-junction",
          title: "电缆-电缆终端头",
        },
        {
          url: require("../../assets/icons/变电站+架空线.png"),
          ref: "jkx-sub",
          title: "架空线-站房-变压器",
        },
        {
          url: require("../../assets/icons/变电站+电缆.png"),
          ref: "dl-sub",
          title: "电缆-站房-变压器",
        },
        {
          url: require("../../assets/icons/变电站+架空线.png"),
          ref: "jkx-msub",
          title: "架空线-站房-母线-变压器",
        },
        {
          url: require("../../assets/icons/变电站+电缆.png"),
          ref: "dl-msub",
          title: "电缆-站房-母线-变压器",
        },
      ],
```

上面这个poleoptions配置并不是这个地图上面的图元，而是在规划的的时候用来选择的

```js
   /**
       * 规划时监听右键
       */
      //给地图对象添加contextmenu方法
      getState('mapData').mapObj.on("contextmenu", (e) => {
          //是否激活添加杆塔-线路模式  
        if (getState('drawStore').drawIsOpen) {
          let str = "";
          for (let item of this.poleOptions) {
            str +=
                //这里循环操作，给每个杆撑选择都添加了点击事件text
                `
              <div class="text-center" style="width: 80px; height: 80px; padding: 0 5px" id="${item.ref}" onclick="test('${item.ref}', '${e.latlng.lat}', '${e.latlng.lng}')">
                <div style="background: url(${item.url}); background-size: 100% 100%; width: 50px; height: 50px; margin: 0 auto"></div>
                ${item.title}
              </div>
            `;
          }
          // 把上一个提示框清除掉 可能因为定位到该馈线会弹出提示框
          getState('popup') && getState('popup').remove();
          this.$yyHot.update('popup', BM.popup({ closeOnClick: true })
            .setLatLng(e.latlng)
            .setContent(
              `<div style="display: flex; flex-wrap: wrap; width: 240px;">`
              +
              str
              +
              `</div>`
            )
            .addTo(getState('mapData').mapObj));
        }
      });
```

这里面给地图添加了一个事件，下面是一个click事件添加在地图上面的示例

```js
 map.on('click',function(e){
            var str='lat:'+e.latlng.lat+',lng:'+e.latlng.lng;
            alert(str);
        });
```

上面添加的不是click事件而是contextmenu事件

```
contextmenu		当用户在地图上按下鼠标右键时触发，防止默认浏览器上下文菜单显示此事件是否有侦听器。当用户持续一次触摸（也称为长按）时，也会在手机上触发。
```

给地图添加的右键事件里面的if判断

```js
  // 画线状态管理
  drawStore: {
    // 是否是添加杆塔-线路模式
    drawIsOpen: false,
    // 存储着杆塔-线路模式的起点线路坐标（latLng）
    drawStart: null,
    // 初始坐标
    originDrawStart: null
  },
```



### 渲染图元

![1663642402250](images/1663642402250.png)

图上图上绿色的、玫红色的圆圈是35kv变电站、100kv变电站等但是都没有在这个撑杆选择里面

是在Mapoptions.js里面的 下面只用一个例子做示例

```js
 
//标注图片配置
export const _MARKERSSTYLE_ = {
     ['transSub35']: function (options) {
        return {
            icon: BM.icon({
                iconUrl:  require(`../assets/icons/35kV变电站.png`), //图片路径
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            })
        }
    },
}

```

这个配置是在initMasrkers

```js
 /**
     * 3.初始化标记点
     */
    initMarkers() {
      //配置生成
      let markerOption = {};
      //循环配置里面的markerstyle
      for (const key in _OPT_._MARKERSSTYLE_) {
          //判断属性名是不是从自身来的，而不是继承来的
        if (_OPT_._MARKERSSTYLE_.hasOwnProperty(key)) {
          markerOption[key] = _OPT_._MARKERSSTYLE_[key];
        }
      }
        //更新vuex中图元的选择
      this.$yyHot.update("mapData.markerOption", markerOption);
    },

```

Object的`hasOwnProperty()`方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。

房子的图标是变电站，房子类型的图标也是在这个_OPT_._MARKERSSTYLE_里面放着

```js
 // 地图对象
  mapData: {
    //地图实例化
    mapObj: null,
    //marker实例化
    // markersObj: null,
    // marker配置，在initMarkers里面完善，
    markerOption: null,
    // 杆塔数组
    markersArr: [],
    //line实例化
    // linesObj: null,
    // line配置
    lineOption: null,
    // 馈线数组
    linesArr: [],
    //circle实例化,
    circleObj: null,
    //markers/lines数据
    inoMarkers: null,
    //处理后点聚合数据
    parMarkers: null,
    //编辑器
    editor: null,
    //当前地图信息
    mapInfo: {
      //鼠标指针信息
      mouseMsg: null,
      //地图缩放等级
      mapLevel: 13,
    }
  },
```

现在有了mapData.markerOption,里面是一个对象，

```js
{
    ['transSub35']： function (options) {
        return {
            icon: BM.icon({
                iconUrl:  require(`../assets/icons/35kV变电站.png`), //图片路径
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            })
        }
    },
}
```



initMa真正将图元渲染到页面上面

```js
//this.renderLine(res.data, null, true);
//renderLine(res, styleId, isAll = false, isNew = false)
//indexMap里面调用initMa也注释掉
//渲染其他图标
  this.$refs.map.initMa(markers, null, { isAll, isNew });
//渲染变电站
this.$refs.map.initMa(transSubs, null, { isTransSub: true, isNew });
```

上面第一次调用的

![1663818570090](images/1663818570090.png)

第二次调用的option

![1663818546917](images/1663818546917.png)



```js
 initMa(markers, center, option = {}) {
      let mr = [];
      if (center) {
        getState("mapData").mapObj.setView(center, _OPT_._PROPS_.ORIGIN_ZOOM);
      }

      let marLayer;
      //把每个图元渲染到页面上面去
      markers.forEach(mar => {
        if (mar.position) {
          let marker = BM.marker(mar.position, {
            ...getState("mapData").markerOption[mar.styleId]({}),
            id: ++window.bigemapId
          });
          mar.map_id = window.bigemapId;
          mr.push(marker);
        }
      })
      //这里就是用来渲染变电站的
      if (option.isTransSub) {
        marLayer = this.addCanvasMarkers(mr)
      } 
     //
     else if (option.isAll) {
        marLayer = this.addCanvasMarkers(mr);

        let cont = marLayer.getPane().getElementsByTagName('canvas')
        // 记录最新的 canvas 图层
        this.$yyHot.update('layers.allMarkersLayer', cont.item(cont.length - 1))
        // 先隐藏
        cont.item(cont.length - 1).style.visibility = 'hidden'
      } 
     else if (option.isNew) {
        this.$yyHot.update('newMarkersArr', Object.freeze(mr))
      } 
     else if (option.isFlow) {
        this.$yyHot.update('flowMarkersArr', Object.freeze(mr))
      } 
     else {
        this.$yyHot.update("mapData.markersArr", Object.freeze(mr));
      }
    },
```

indexMap里面传入的markers是从哪里来的，结构是怎么样的：可以参考上面的lines里面的信息是怎么样的

```
setView( <LatLng> center, <Number> zoom, <Zoom/pan options> options?)	this	
设置地图位置（地理位置和缩放级别））
```

如果是变电站的话

```js
    addCanvasMarkers(marArr) {
      let layer = BM.canvasIconLayer({}).addTo(getState('mapData').mapObj);
      marArr.map(n => {
        layer.addLayer(n)
      })
      return layer;
    },
```

isAll那里的那个else if如果去掉的话

![1663831856834](images/1663831856834.png)





![1663834723136](images/1663834723136.png)



![1663834769639](images/1663834769639.png)



线上面的小点是通过initMa渲染的，接口里面传回来的数据poleVOList就是馈线上面的点











#### 测试

注释掉渲染图元的init.makers在init函数里面，就会出现

加载设备中。。这个组件一直出现，并且报错

![1663641575064](images/1663641575064.png)

```js
//indexMap里面调用initMa也注释掉
  this.$refs.map.initMa(markers, null, { isAll, isNew });
      this.$refs.map.initMa(transSubs, null, { isTransSub: true, isNew });
```

就不会出现一直加载设备中的情况，这时候就算不注释掉init.Markers函数的调用也是像下图一样的情况



放大看的馈线地图就变成了这样

![1663641793889](images/1663641793889.png)

![1663641820003](images/1663641820003.png)



缩小之后馈线就是这样

![1663642154810](images/1663642154810.png)



并且这个线和这个地图也不适配了 线也变少了？



















### 项目结构

这个项目的结构到底是怎么样的？

首先从index.html进入，进入到组件app

```html
  <div>
        <Home ref="Home"/>
    </div>
```

组件app又转到Home组件 home组件里面有登陆的，登陆进去之后就跳转到indexmap界面

```js
import yyMap from "../components/yy-cpns/yy-map";
  components: {
    yyMap,
  },
```

像这样引入到vue中的组件

```js
 <yy-map allLineMapId="map" ref="map" :canSearch="false"></yy-map>
```

在页面中这样引用



这里的login是写死的

```js
if (
        this.loginForm.username === "SGAdmin" &&
        this.loginForm.password === "Lab315!315@"
      ) {
        sessionStorage.setItem("SG_TOKEN", true);
        this.$yyHot.update('user', {userName: 'SGAdmin'})
        this.$router.replace("index-map");
        this.$yyHot.showSnackbar({
          text: "登录成功！",
          type: "success",
        });
        return;
      } else {
        this.$yyHot.showSnackbar({
          text: "失败",
          type: "error",
        });
        return;
      }
```

yyHot是用来干什么的？yyHot是用来更新vuex里面的数据的

yyHot.js里面有

```js
const update = function (key, value) {
    store.commit({
        type: "_update",
        data: {
            key,
            value,
        },
    });
}
```



#### vuex的使用

关于store里面的内容

```js
import state from './state';
import mutations from './mutations';
import actions from './actions';
Vue.use(Vuex)
export default new Vuex.Store({
  state,
  mutations,
  actions,
  modules: {}
})
```

state、mutations分别放在不同的文件中

```js
 // 更新vuex中state数据
  _update(state, {
    data
  }) {
    if(typeof data.key === 'string') {
      toKey(data.key, data.value)
    } else {
      data.key.forEach((k, i) => {
        toKey(k, data.value[i])
      });
    }

    function toKey(str, data) {
      let keys = str.split('.')
      let lastKey = keys.pop()
      let _state = keys.reduce((pre, aft) => {
        return pre[aft]
      }, state)

      _state[lastKey] = data
    }
  }
```



### ProblemTotal问题库

![1663379515276](images/1663379515276.png)

```js
import yyPlanning from '../components/yy-cpns/yy-planning';
```

这个问题库中引入的yy-planning的组件，这个组件的作用？

注释掉yyPlanning之后，也没什么问题出现？

```
定位至该馈线 当前馈线规划问题
```

yyPlanning是点击未入库的时候出现的？ 不是只要点击这一条就会出现问题详情

```js
    switchChipText(index) {
      switch (index) {
        case 0:
          return "未入库";
        case 1:
          return "已入库";
        case 2:
          return "已进入备选群";
        case 3:
          return "已进入项目库";
      }
    },
```

点击以该馈线做规划

这个问题总览里面的表体是通过v-data-table来渲染的，

```html
 <v-data-table :headers="headersZL" :items="filterDessertsZL" dark class="w-pct-100 h-pct-100 bg-darkRGBA5-theme"
      item-key="questionEncoding" dense show-expand single-expand :items-per-page="20" :options.sync="pagination"
      :footer-props="{
        itemsPerPageOptions:[5, 10, 20],
        itemsPerPageText:'每页行数',
        pageText:`第${pagination.page}页`,
        showFirstLastPage: true
      }" :search="search" @dblclick:row="setCurQuestion" :loading="loadingName === 'loadingTable'"
      loading-text="大量数据加载中...">
```

```
 @dblclick:row="setCurQuestion"
```

通过上面这一句进行对点击每个问题进行打开问题总览

```js
    /**
     * 通过双击行来进入问题页面
     */
    setCurQuestion(e, item) {
      this.$store.state.selectedcircuitLine = item.item.circuitLineMRid
      this.$store.state.openStatus.dialogProblem = true;
      this.$store.state.curQuestion = item.item;
    },
```

打开问题总览就等于打开了yy-problem组件，yy-problem组件上面的

![1663845398193](images/1663845398193.png)

以该馈线做规划按钮实际上面就是yy-planning.vue这个组件



### yyplannning

![1664180332442](images/1664180332442.png)

```js
 <v-card class="dbg mt-n4 bg-transparent" width="100%">
                    <!-- 表格 -->
                    <yy-table-curcuit class="bg-darkRGBA5-theme" :data="$store.state.curKX.curKXInfo">
                    </yy-table-curcuit>
                  </v-card>
```

在state里面

```js
  curKX: {
    // 当前馈线信息-用于地图上对当前馈线进行展示
    curKXInfo: null,

    // 当前馈线下问题
    curKXQuestion: [],

    // 当前馈线设备数据-用于地图上对当前馈线设备进行渲染
    curKXData: null,

    // 当前馈线单个设备数据-用于地图上对当前馈线设备进行渲染
    curKXOnlyData: null,
  },
```

#### 







```html
 <v-btn rounded class="primary ml-5" v-bind="attrs" v-on="on" @click="loadCircuitLine">以该馈线作规划</v-btn>
```

点击以该馈线做规划就会调用loadCircuitLine这个函数

```js
  // 加载馈线信息
    async loadCircuitLine() {
      this.map = true
        //把是否正在规划窗口改成true ，更新现在的地图对象为规划地图对象
      this.$yyHot.update(
        ["isDrawing", "mapData.mapObj", "mapData.mapInfo.mapLevel"],
        [true, getState('planMap'), _OPT_._PROPS_.ORIGIN_ZOOM]
      );
      this.loadCircuitLineInfo();
    }
```

yyHot

```js
const update = function (key, value) {
    store.commit({
        type: "_update",
        data: {
            key,
            value,
        },
    });
}
```

state

```js
 // 规划地图
  planMap: null,
```

函数里面又调用loadCircuitLineInfo的函数

```js
 // 加载馈线数据
    async loadCircuitLineInfo() {
      //代表现在正在加载中
      this.loadingDeviceData = true;
      //svfmap原本等于0，现在改为false，是指现在不要展示svgmap
      this.svgMap = false;
      //调用这个函数下载svg文件
      this.$nextTick().then(() => {
        this.$refs.svgMaster.handleDownload();
      })
      // this.$refs.svgMaster.destoryDraw()

      // 根据id获取单个馈线信息以及其所属问题 selectedcircuitLine就是现在杯选中的馈线id
      API.getKXInfo({
        lineId: getState('selectedcircuitLine'),
      })
        .then(({ data, message }) => {
          // 存储
          this.$yyHot.update(['curKX.curKXInfo', 'curKX.curKXQuestion'], [data.lineProblem, data.questions])
          //弹出消息弹窗提示
          this.$yyHot.showSnackbar({
            text: "获取馈线信息" + message,
            type: "success",
          });
        })
        .catch(({ message }) => {
          this.$yyHot.showSnackbar({
            text: "获取馈线信息" + message,
            type: "error",
          });
        });
      //调用函数获取最新版本的规划 更新lastestGH和lastestCG数据
      this.getNewestHistory();
      //调用获取馈线组的接口 这个接口调用完就是结束加载馈线信息这个函数了
      await API.getLineGroup({
        circuitLineMRid: getState('selectedcircuitLine'),
      }).then(({ data }) => {
        //这里下面的成功操作是从indexmap的renderLine里面复制过来的
        let lines = [],
          markers = [],
          newMarkers = [],
          newLines = [],
          transSubs = [];
        // let center = null
        data.forEach((data, index) => {
          // 将主干线的变电站作为中心点
          if (index === 0) {
            //用来做定位到该馈线的坐标
            this.lineInfo = {
              latLng: this.$yyMap.locatToLatLng(
                data.transSubstationVO.location
              ),
              message: data.transSubstationVO.name,
            };
          }
          // 遍历单个线路的所有设备
          for (let key in data) {
            if (
              key === "circuitLineMRid" ||
              key === "circuitLineName" ||
              key === "ringSwitchVOList"
            ) {
              continue;
            }
            const element = data[key];
            // 如果设备是线
            if (
              this.$yyMap.judgeType(this.$yyMap.setKeyTypeToDeviceType(key)) ===
              "line"
            ) {
              lines.push(
                ...this.$yyMap.backDataToMapData(
                  element,
                  this.$yyMap.setKeyTypeToDeviceType(key),
                  index
                )
              );
            } else {
              // 否则 如果设备是点
              if (key === "transSubstationVO") {
                // 如果设备是站房
                transSubs.push(
                  ...this.$yyMap.backDataToMapData(
                    element,
                    this.$yyMap.setKeyTypeToDeviceType(key),
                    "transSub" + element.name.split("kV")[0]
                  )
                );
              } else {
                markers.push(
                  ...this.$yyMap.backDataToMapData(
                    element,
                    this.$yyMap.setKeyTypeToDeviceType(key)
                  )
                );
              }
            }
          }
        });
        //获取新规划的数据
        API.getNewDevice({
          circuitLineMRid: getState('selectedcircuitLine'),
        }).then(({ data }) => {
            //这里和上面不同的就是变量用的是newlines和newmakers
          data.forEach((data, index) => {
            // 遍历单个线路的所有设备 
            for (let key in data) {
              if (
                key === "circuitLineMRid" ||
                key === "circuitLineName" ||
                key === "ringSwitchVOList"
              ) {
                continue;
              }
              const element = data[key];
              // 如果设备是线
              if (
                this.$yyMap.judgeType(
                  this.$yyMap.setKeyTypeToDeviceType(key)
                ) === "line"
              ) {
                newLines.push(
                  ...this.$yyMap.backDataToMapData(
                    element,
                    this.$yyMap.setKeyTypeToDeviceType(key),
                    "style_red_dash"
                  )
                );
              } else {
                newMarkers.push(
                  ...this.$yyMap.backDataToMapData(
                    element,
                    this.$yyMap.setKeyTypeToDeviceType(key)
                  )
                );
              }
            }
          });
          //更新现在的数据
          this.$yyHot.update(["markers", "lines", "transSubs", 'newMarkers', 'newLines'], [markers, lines, {
            data: transSubs,
            center: this.lineInfo.latLng,
          }, newMarkers, newLines])
           //利用渲染函数initMa还有initLi把原本的点线还有新规划的电线渲染上去
          this.$nextTick(() => {
            this.$refs.yyMap.initMa(getState("markers"));
            this.$refs.yyMap.initMa(getState('newMarkers'), null, { isNew: true });
            this.$refs.yyMap.initMa(getState("transSubs").data, getState("transSubs").center, {
              isTransSub: true,
            });
            this.$refs.yyMap.initLi([...getState("lines"), ...getState('newLines')]);
          })

          this.loadingDeviceData = false;
        });
      });
    },
```



#### svgmap

```js
  <v-btn :color="svgMap ? 'primary' : 'secondary'" :loading="!isSvgShow" @click="svgMap = 1"
                style="flex: 2; margin: 0 5px">
                SVG
                <template v-slot:loader>
                  <span>SVG Loading...</span>
                </template>
              </v-btn>
```

根据点击这个svg按钮就让svgmap变成1，说明这个svgmap就是用来说明现在是否是要显示svg图片

```js
  <svg-master @drawdown="handleSvgDrawDown" style="
                position: absolute;
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;
                height: 88vh;
              " ref="svgMaster" :style="{ zIndex: svgMap ? 2 : 0 }">
            </svg-master>
```

如果svgmap==true的话，就是让svg-master的层级变得更高把地图盖住

上面这个svg-master是一个页面

```js
import svgMaster from "@/views/svg-master";
```



#### 上面用到的接口getKXInfo

```js
/**
 * 根据id获取单个馈线信息以及其所属问题
 * @param {Array} curcuitId 馈线id
 * 
 */
export function getKXInfo(config) {
    return yyRequest({
        url: KJB + NWOPT.GETCURCUITLINEDATA,
        params: config,
    })
}
```



上面调用getKXInfo获得是数据

![1664183757771](images/1664183757771.png)



#### 获取最新版本的规划getNewestHistory

```js
    // 获取最新版本的规划
    async getNewestHistory() {
      // let lastest = 1
      //lastestGH最新的一次规划 lastestCG最后的一次重构
      this.lastestGH = null;
      this.lastestCG = null;
      //调用查询规划历史的api
      await API.selectPlanningHistory({
        //传入现在选中的馈线的id
        circuitLineMRid: this.$store.state.selectedcircuitLine,
      }).then((res) => {
        //如果返回的数据数组有长度，就取第一个
        if (res.data.length) {
          //最后的规划就是这个数据的第一个元素
          this.lastestGH = res.data[0];
          // lastest = `${res.data[0].currentCircuitLineMRid}-${res.data[0].time}`
        }
      });

      // 新增开关历史
      await API.geiSwitchControl({
        circuitLineMRid: this.$store.state.selectedcircuitLine,
      }).then((res) => {
        if (res.data.length) {
           //返回数据长度不为0并且lastestGH的为空 或者是返回数据长度不为0并且现在这个开关历史的时间比那个馈线规划历史时间晚，时间晚就说明是更新的
          if (!this.lastestGH || res.data[0].time > this.lastestGH.time) {
            this.lastestGH = res.data[0];
          }
          // if(lastest === 1 || res.data[0].time > `${lastest.split('-')[1]}-${lastest.split('-')[2]}-${lastest.split('-')[3]}`) {
          //     lastest = `${res.data[0].currentCircuitLineMRid}-${res.data[0].time}`
          // }
        }
      });

      // 重构历史
      await API.selectRestructureLineHistory({
        circuitLineMRid: this.$store.state.selectedcircuitLine,
      }).then((res) => {
        if (res.data.length) {
          this.lastestCG = res.data[0];
          // if(lastest === 1 || res.data[0].time > `${lastest.split('-')[1]}-${lastest.split('-')[2]}-${lastest.split('-')[3]}`) {
          //     lastest = `${res.data[0].currentCircuitLineMRid}-${res.data[0].time}`
          // }
        }
      });
      // this.$store.state.lastest = lastest
    },
```





#### 查询规划历史调用

```js
// 查询规划历史
export function selectPlanningHistory(data) {
    return chRequest({
        url: LLT + NWOPT.SELECTPLANNINGHISTORY,
        method: 'post',
        data: qs.stringify(data),
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
    })
}
```











### yy-single-table

![1663836959424](images/1663836959424.png)







